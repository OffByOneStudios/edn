// Sum / Enum macros
#include "rustlite/macros/context.hpp"
#include "rustlite/expand.hpp"
#include "edn/transform.hpp"
#include "rustlite/macros/helpers.hpp"
#include <unordered_set>

using namespace edn;
namespace rustlite {

using rustlite::rl_make_sym; using rustlite::rl_make_i64; using rustlite::rl_gensym;

// Sum / Enum related macros: rsum, rnone/rsome/rok/rerr, renum/enum, ematch/rmatch, enum-ctor.
// Duplicate legacy helpers removed; only rl_* factory helpers should be used.

void register_sum_enum_macros(edn::Transformer& tx, const std::shared_ptr<MacroContext>& ctx){
    // rsum
    tx.add_macro("rsum", [](const list& form)->std::optional<node_ptr>{
        auto& el=form.elems; if(el.size()<5) return std::nullopt; if(!std::holds_alternative<symbol>(el[1]->data)||!std::holds_alternative<symbol>(el[2]->data)||!std::holds_alternative<symbol>(el[3]->data)) return std::nullopt; node_ptr dst=el[1]; auto sumName=std::get<symbol>(el[2]->data).name; auto variant=std::get<symbol>(el[3]->data).name; node_ptr vals=nullptr; for(size_t i=4;i+1<el.size(); i+=2){ if(!std::holds_alternative<keyword>(el[i]->data)) break; if(std::get<keyword>(el[i]->data).name=="vals") vals=el[i+1]; } if(!vals || !std::holds_alternative<vector_t>(vals->data)) return std::nullopt; list l; l.elems = { rl_make_sym("sum-new"), dst, rl_make_sym(sumName), rl_make_sym(variant), vals }; return std::make_shared<node>( node{ l, form.elems.front()->metadata } ); });
    tx.add_macro("rnone", [](const list& form)->std::optional<node_ptr>{ auto& el=form.elems; if(el.size()<3) return std::nullopt; if(!std::holds_alternative<symbol>(el[1]->data)||!std::holds_alternative<symbol>(el[2]->data)) return std::nullopt; node_ptr dst=el[1]; auto sumName=std::get<symbol>(el[2]->data).name; vector_t empty; list l; l.elems={ rl_make_sym("sum-new"), dst, rl_make_sym(sumName), rl_make_sym("None"), std::make_shared<node>( node{ empty, {} } ) }; return std::make_shared<node>( node{ l, form.elems.front()->metadata } ); });
    auto single_val = [](const list& form,const char* variant)->std::optional<node_ptr>{ auto& el=form.elems; if(el.size()<4) return std::nullopt; if(!std::holds_alternative<symbol>(el[1]->data)||!std::holds_alternative<symbol>(el[2]->data)) return std::nullopt; node_ptr dst=el[1]; auto sumName=std::get<symbol>(el[2]->data).name; node_ptr val = el[3]; vector_t v; v.elems.push_back(val); list l; l.elems={ rl_make_sym("sum-new"), dst, rl_make_sym(sumName), rl_make_sym(variant), std::make_shared<node>( node{ v, {} } ) }; return std::make_shared<node>( node{ l, form.elems.front()->metadata } ); };
    tx.add_macro("rsome", [single_val](const list& f){ return single_val(f,"Some"); });
    tx.add_macro("rok", [single_val](const list& f){ return single_val(f,"Ok"); });
    tx.add_macro("rerr", [single_val](const list& f){ return single_val(f,"Err"); });
    // renum
    tx.add_macro("renum", [ctx](const list& form)->std::optional<node_ptr>{ auto& el=form.elems; if(el.size()<3) return std::nullopt; node_ptr nameN=nullptr; node_ptr variantsV=nullptr; for(size_t i=1;i+1<el.size(); i+=2){ if(!std::holds_alternative<keyword>(el[i]->data)) break; auto kw=std::get<keyword>(el[i]->data).name; auto v=el[i+1]; if(kw=="name") nameN=v; else if(kw=="variants") variantsV=v; } if(!nameN || !variantsV || !std::holds_alternative<vector_t>(variantsV->data)) return std::nullopt; if(std::holds_alternative<symbol>(nameN->data)){ ctx->enumVariantCounts[ std::get<symbol>(nameN->data).name ] = std::get<vector_t>(variantsV->data).elems.size(); } vector_t outVars; for(auto &vn : std::get<vector_t>(variantsV->data).elems){ if(std::holds_alternative<symbol>(vn->data)){ list v; v.elems={ rl_make_sym("variant"), edn::n_kw("name"), vn, edn::n_kw("fields"), std::make_shared<node>( node{ vector_t{}, {} } ) }; outVars.elems.push_back(std::make_shared<node>( node{ v, {} } )); } else if(std::holds_alternative<list>(vn->data)){ auto vl=std::get<list>(vn->data); if(vl.elems.empty()||!std::holds_alternative<symbol>(vl.elems[0]->data)) return std::nullopt; vector_t fields; for(size_t i=1;i<vl.elems.size(); ++i) fields.elems.push_back(vl.elems[i]); list v; v.elems={ rl_make_sym("variant"), edn::n_kw("name"), vl.elems[0], edn::n_kw("fields"), std::make_shared<node>( node{ fields, {} } ) }; outVars.elems.push_back(std::make_shared<node>( node{ v, {} } )); } else return std::nullopt; } list s; s.elems={ rl_make_sym("sum"), edn::n_kw("name"), nameN, edn::n_kw("variants"), std::make_shared<node>( node{ outVars, {} } ) }; return std::make_shared<node>( node{ s, form.elems.front()->metadata } ); });
    // enum alias
    tx.add_macro("enum", [](const list& form)->std::optional<node_ptr>{ auto l=form; if(l.elems.size()<3) return std::nullopt; l.elems[0]=rl_make_sym("renum"); return std::make_shared<node>( node{ l, form.elems.front()->metadata } ); });
    // ematch
    tx.add_macro("ematch", [ctx](const list& form)->std::optional<node_ptr>{ auto &el=form.elems; if(el.size()<6) return std::nullopt; if(!std::holds_alternative<symbol>(el[1]->data)||!std::holds_alternative<symbol>(el[3]->data)) return std::nullopt; node_ptr dst=el[1]; node_ptr retTy=el[2]; std::string enumName = std::get<symbol>(el[3]->data).name; node_ptr scrut=el[4]; node_ptr armsV=nullptr; for(size_t i=5;i+1<el.size(); i+=2){ if(!std::holds_alternative<keyword>(el[i]->data)) break; auto kw=std::get<keyword>(el[i]->data).name; if(kw=="arms"||kw=="cases") armsV=el[i+1]; } if(!armsV || !std::holds_alternative<vector_t>(armsV->data)) return std::nullopt; size_t need = ctx->enumVariantCounts[enumName]; std::unordered_set<std::string> seen; vector_t outCases; for(auto &armNode : std::get<vector_t>(armsV->data).elems){ if(!armNode || !std::holds_alternative<list>(armNode->data)) return std::nullopt; auto arm=std::get<list>(armNode->data); if(arm.elems.empty()||!std::holds_alternative<symbol>(arm.elems[0]->data)) return std::nullopt; auto head=std::get<symbol>(arm.elems[0]->data).name; if(head!="arm" && head!="case") return std::nullopt; if(arm.elems.size()<2 || !std::holds_alternative<symbol>(arm.elems[1]->data)) return std::nullopt; std::string variant=std::get<symbol>(arm.elems[1]->data).name; seen.insert(variant); if(head=="case"){ outCases.elems.push_back(armNode); continue; } node_ptr bodyVec=nullptr; node_ptr bindsList=nullptr; for(size_t i=2;i+1<arm.elems.size(); i+=2){ if(!std::holds_alternative<keyword>(arm.elems[i]->data)) break; auto kw=std::get<keyword>(arm.elems[i]->data).name; auto v=arm.elems[i+1]; if(kw=="body") bodyVec=v; else if(kw=="binds") bindsList=v; } if(!bodyVec || !std::holds_alternative<vector_t>(bodyVec->data)) return std::nullopt; list caseL; caseL.elems={ rl_make_sym("case"), rl_make_sym(variant) }; if(bindsList){ if(!std::holds_alternative<vector_t>(bindsList->data)) return std::nullopt; vector_t bindsOut; size_t bidx=0; for(auto &b : std::get<vector_t>(bindsList->data).elems){ if(!std::holds_alternative<symbol>(b->data)) return std::nullopt; list bd; bd.elems={ rl_make_sym("bind"), b, rl_make_i64((int64_t)bidx) }; bindsOut.elems.push_back(std::make_shared<node>( node{ bd, {} } )); ++bidx; } caseL.elems.push_back(edn::n_kw("binds")); caseL.elems.push_back(std::make_shared<node>( node{ bindsOut, {} } )); } caseL.elems.push_back(edn::n_kw("body")); caseL.elems.push_back(bodyVec); outCases.elems.push_back(std::make_shared<node>( node{ caseL, {} } )); }
        bool exhaustive = (need>0 && seen.size()==need); list matchL; matchL.elems={ rl_make_sym("match"), dst, retTy, rl_make_sym(enumName), scrut, edn::n_kw("cases"), std::make_shared<node>( node{ outCases, {} } ) }; auto md=form.elems.front()->metadata; md["ematch"] = detail::make_node(true); if(exhaustive) md["ematch-exhaustive"] = detail::make_node(true); return std::make_shared<node>( node{ matchL, md } ); });
    // rmatch (legacy) - always requires :else vector producing :value. No exhaustiveness metadata.
    tx.add_macro("rmatch", [ctx](const list& form)->std::optional<node_ptr>{
        auto &el=form.elems; if(el.size()<6) return std::nullopt;
        if(!std::holds_alternative<symbol>(el[1]->data)||!std::holds_alternative<symbol>(el[3]->data)) return std::nullopt;
        node_ptr dst=el[1]; node_ptr retTy=el[2]; std::string enumName=std::get<symbol>(el[3]->data).name; node_ptr scrut=el[4];
        node_ptr armsV=nullptr; node_ptr elseV=nullptr; for(size_t i=5;i+1<el.size(); i+=2){ if(!std::holds_alternative<keyword>(el[i]->data)) break; auto kw=std::get<keyword>(el[i]->data).name; auto v=el[i+1]; if(kw=="arms"||kw=="cases") armsV=v; else if(kw=="else"||kw=="default") elseV=v; }
        if(!armsV || !std::holds_alternative<vector_t>(armsV->data)) return std::nullopt; if(!elseV || !std::holds_alternative<vector_t>(elseV->data)) return std::nullopt;
        vector_t outCases; for(auto &armNode : std::get<vector_t>(armsV->data).elems){ if(!armNode || !std::holds_alternative<list>(armNode->data)) return std::nullopt; auto arm=std::get<list>(armNode->data); if(arm.elems.size()<2 || !std::holds_alternative<symbol>(arm.elems[0]->data) || !std::holds_alternative<symbol>(arm.elems[1]->data)) return std::nullopt; auto head=std::get<symbol>(arm.elems[0]->data).name; if(head!="arm" && head!="case") return std::nullopt; std::string variant=std::get<symbol>(arm.elems[1]->data).name; if(head=="case"){ // legacy already in core form
                outCases.elems.push_back(armNode); continue; }
            node_ptr bodyVec=nullptr; node_ptr bindsList=nullptr; for(size_t i=2;i+1<arm.elems.size(); i+=2){ if(!std::holds_alternative<keyword>(arm.elems[i]->data)) break; auto kw=std::get<keyword>(arm.elems[i]->data).name; auto v=arm.elems[i+1]; if(kw=="body") bodyVec=v; else if(kw=="binds") bindsList=v; }
            if(!bodyVec || !std::holds_alternative<vector_t>(bodyVec->data)) return std::nullopt;
            // Auto-inject :value %dst if not present inside bodyVec
            bool haveValue=false; for(size_t bi=0; bi+1<std::get<vector_t>(bodyVec->data).elems.size(); ++bi){ auto &n=std::get<vector_t>(bodyVec->data).elems[bi]; if(n && std::holds_alternative<keyword>(n->data) && std::get<keyword>(n->data).name=="value") { haveValue=true; break; } }
            if(!haveValue){ auto &bElems = std::get<vector_t>(bodyVec->data).elems; bElems.push_back(edn::n_kw("value")); bElems.push_back(dst); }
            list caseL; caseL.elems={ rl_make_sym("case"), rl_make_sym(variant) };
            if(bindsList){ if(!std::holds_alternative<vector_t>(bindsList->data)) return std::nullopt; vector_t bindsOut; size_t bidx=0; for(auto &b : std::get<vector_t>(bindsList->data).elems){ if(!std::holds_alternative<symbol>(b->data)) return std::nullopt; list bd; bd.elems={ rl_make_sym("bind"), b, rl_make_i64((int64_t)bidx) }; bindsOut.elems.push_back(std::make_shared<node>( node{ bd, {} } )); ++bidx; } caseL.elems.push_back(edn::n_kw("binds")); caseL.elems.push_back(std::make_shared<node>( node{ bindsOut, {} } )); }
            caseL.elems.push_back(edn::n_kw("body")); caseL.elems.push_back(bodyVec);
            outCases.elems.push_back(std::make_shared<node>( node{ caseL, {} } ));
        }
        // Ensure else/default vector has :value %dst
        bool elseHasValue=false; for(size_t i=0;i+1<std::get<vector_t>(elseV->data).elems.size(); ++i){ auto &n=std::get<vector_t>(elseV->data).elems[i]; if(n && std::holds_alternative<keyword>(n->data) && std::get<keyword>(n->data).name=="value") { elseHasValue=true; break; } }
        if(!elseHasValue){ auto &eElems = std::get<vector_t>(elseV->data).elems; eElems.push_back(edn::n_kw("value")); eElems.push_back(dst); }
        list matchL; matchL.elems={ rl_make_sym("match"), dst, retTy, rl_make_sym(enumName), scrut, edn::n_kw("cases"), std::make_shared<node>( node{ outCases, {} } ), edn::n_kw("default"), elseV };
        return std::make_shared<node>( node{ matchL, form.elems.front()->metadata } );
    });
    // enum-ctor
    tx.add_macro("enum-ctor", [](const list& form)->std::optional<node_ptr>{ auto &el=form.elems; if(el.size()<4) return std::nullopt; if(!std::holds_alternative<symbol>(el[1]->data)||!std::holds_alternative<symbol>(el[2]->data)||!std::holds_alternative<symbol>(el[3]->data)) return std::nullopt; auto dst=el[1]; auto typeName=std::get<symbol>(el[2]->data).name; auto variantName=std::get<symbol>(el[3]->data).name; vector_t vals; for(size_t i=4;i<el.size();++i) vals.elems.push_back(el[i]); list l; l.elems={ rl_make_sym("sum-new"), dst, rl_make_sym(typeName), rl_make_sym(variantName), std::make_shared<node>( node{ vals, {} } ) }; return std::make_shared<node>( node{ l, form.elems.front()->metadata } ); });
}

} // namespace rustlite
