# EDN-0006: Persistent `llvm::cast` Assertion in Phase 4 Aggregate (ABI Golden) Test

Status: CLOSED (2025-08-22)

## Summary
A reproducible `Assertion failed: (isa<To>(Val) && "cast<Ty>() argument of incompatible type!")` (LLVM `Casting.h:578`) aborts the `edn.phase4.full` aggregate test during the final "ABI golden test" segment (module `abi`). All individual preceding Phase 4 feature tests (sums, traits, closures, debug info, EH, coroutines, passes) complete successfully when run *inside* the aggregate, and standalone tests pass. The failure appears only in the monolithic Phase 4 aggregate run and always after Debug Info (DI) emission for struct `T` in the ABI golden test.

## Reproduction
```
cmake --build build -j6
cd build
ctest -V -R edn.phase4.full   # aborts ~1.3–1.6s in
```
Environment automatically sets `EDN_ENABLE_PASSES=0` inside the ABI golden test.
Disabling debug info via `EDN_ENABLE_DEBUG=0` does **not** prevent the crash.

## Observed Output (Tail Excerpt)
```
[phase4] ABI golden test (no verifier)...
[di] building struct DI for 'T' with 2 fields
[di][member] struct=T i=0 fid=3 fLL.kind=13 fDI=0x...
[di][member] struct=T i=1 fid=23 fLL.kind=17 fDI=0x...
[di] built 2 member DI entries for struct 'T'
Assertion failed: (isa<To>(Val) && "cast<Ty>() argument of incompatible type!"), function cast, file Casting.h, line 578.
```
(Additional closure / pass test log lines sometimes appear buffered after the assertion line, but the process aborts here.)

## Expected Behavior
`edn.phase4.full` should succeed; ABI golden test should finish, verifying IR snippets without triggering LLVM assertions.

## Investigation Timeline & Changes
| Stage | Action | Result |
|-------|--------|--------|
| 1 | Fixed earlier unrelated ABI mismatch (i32→i64 zext for sum field) | Original golden IR checks pass again. |
| 2 | Crash appeared (LLVM cast assertion) post-fix | Repro stable. |
| 3 | Added bitcast in `closure_ops::handle_call_closure` to restore erased fn ptr type | No change. |
| 4 | Added guards (`isa` / debug prints) around every visible `llvm::cast<...>` in: `edn.cpp`, `closure_ops.cpp`, `pointer_func_ops.cpp`, `memory_ops.cpp` | None of these reported a mismatch before crash. |
| 5 | Instrumented `sum_ops::handle_sum_new` to log field sizes/types | Logged two fields twice; crash still after logs. |
| 6 | Added DI struct member instrumentation in `debug.cpp` | Showed struct `T` fields: (tag) kind=13, (payload storage) kind=17 before assertion. |
| 7 | Reintroduced verifier inside ABI golden test | Verifier prints `module ok` (so IR is structurally valid from verifier's perspective). |
| 8 | Ran with `EDN_ENABLE_DEBUG=0` | Crash persists -> not gated solely on debug info flag. |

## Key Findings
- Assertion fires *after* DI member creation for struct `T`, but before test can print success message.
- Module verifier reports **no** invalid IR just prior to when we normally would crash (suggests failure occurs later in execution flow, possibly during additional DI finalization or another code path not yet instrumented).
- All directly instrumented `llvm::cast` call sites show correct dynamic type (`isa` checks pass); failing cast is likely inside:
  * Uninstrumented LLVM internals invoked during DIBuilder finalization, OR
  * Remaining uninstrumented project site(s): `exceptions.cpp` (3 casts, already exercised earlier without incident), `collect.cpp` (array cast for constant arrays), or helper functions in layout / size utilities that internally call `llvm::cast` (not yet instrumented).
- DI for simple struct `Point` (two i32 fields) works repeatedly; struct `T` differs by having a variant payload area (likely emitted as a byte array or union-like largest variant storage).

## Hypotheses
1. **Incorrect DI type reuse / recursion**: `diTypeOf` may re-enter and produce a DI node ordering that LLVM later rejects (e.g., constructing members that reference incomplete / mismatched metadata). However, verifier passes and DI for other structs works.
2. **Mismatched underlying LLVM type vs. expected composite in a later pass**: The second field of `struct T` (payload storage) might be emitted as an array or vector; a subsequent helper (layout or DI finalization) performs a `cast<StructType>` or `cast<ArrayType>` failing for this specific shape.
3. **Lifetime / double finalization ordering**: Multiple modules or multiple DIBuilder finalizations in the aggregate test produce a dangling metadata pointer culminating in a failed `cast` when accessed again.
4. **Hidden cast in layout helpers**: Functions in `layout.hpp/cpp` or `types` might internally use `llvm::cast` (not yet grepped) and are triggered only by the sum-type payload structure in ABI golden test.

## Next Diagnostic Steps (Proposed)
1. Instrument all remaining `llvm::cast` inside project sources: search recursively for `cast<` in layout / helper files not yet covered.
2. Add a global `LLVM_ENABLE_ABI_BREAKING_CHECKS` style runtime trap by compiling with `-DLLVM_ENABLE_ABI_BREAKING_CHECKS=1` (if available via vcpkg) to improve assertion context (stack trace?).
3. Emit a stack trace on assertion by running tests under `lldb -- ctest -R edn.phase4.full` or using `LLVM_ENABLE_ASSERTIONS` already (assert prints, but capture backtrace).
4. Temporarily bypass DI emission for the ABI golden test module (`abi`) to confirm DI involvement: add flag to disable `DebugManager::diTypeOf` for that module only; if crash disappears -> isolate DI path.
5. Log *all* type IDs and textual forms for the two struct `T` member LLVM types using `raw_string_ostream` to correlate integer `TypeID` with actual kind.
6. Add incremental disable toggles (e.g. skip `sum-new` instructions inside ABI test body) to confirm whether executing those builders triggers later crash.
7. Force early `DIBuilder::finalize()` after each module emit and before running the next test segment to see if crash timing changes (could reveal double-finalize or stale pointer usage).

## Potential Fix Directions
- Ensure each module's DIBuilder is finalized exactly once; audit `DebugManager` destructor / lifecycle.
- Defensive `dyn_cast` + error logging in `diTypeOf` calls when composing member types; avoid assuming pointer types for payload.
- Replace array-of-bytes payload strategy with an explicitly named struct to simplify DI generation and reduce ambiguous type casts.

## Open Questions
- Why does the assertion not surface for *earlier* sum / struct debug tests that also create array-based storage (if any)?
- Is there any multithreading or static global reinitialization between subtests that could corrupt LLVM type uniquing tables?
- Does the second field of `struct T` differ between modules due to data layout changes (target triple overrides earlier)?

## Instrumentation Added (Current Branch)
- `sum_ops.cpp`: field size/type logs.
- `closure_ops.cpp`: function type sanity prints + bitcast fix.
- `pointer_func_ops.cpp`: `isa` guard before call-indirect.
- `memory_ops.cpp`: array literal cast guard.
- `debug.cpp`: DI struct member logs.
- `edn.cpp`: function emission type guards for definitions and externals.
- `phase4_abi_golden_test.cpp`: Module verifier invocation.

## Files Likely Relevant (Not Yet Instrumented Fully)
- `src/edn/ir/layout.*`
- `src/edn/ir/types.*`
- `src/edn/ir/exceptions.cpp` (casts already exercised but could still intermittently fail)
- `src/edn/ir/collect.cpp` (global constant array / struct building)

## Suggested Owner / Labels
- Area: IR / Debug Info / Sums
- Priority: High (blocks aggregate Phase 4 CI)
- Type: Bug

## Acceptance Criteria (met)
- `ctest -R edn.phase4.full` passes (assertion eliminated) with debug info on/off.
- Root cause documented: invalid `ConstantInt::get` on non-integer type in `const_ops` (fixed by type guard); missing `%struct.ShowVT` snippet resolved by conditional struct + global emission (polish moved to EDN-0007).

## Attachments
(Refer to recent test log output already in repo under `build/Testing/Temporary/LastTest.log` for full trace.)

---
Generated via automated debugging session instrumentation. Further direction: proceed with steps 1–3 under Next Diagnostic Steps.
