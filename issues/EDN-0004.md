# EDN-0004: Debug Info (DI) Expansion & Validation

Status: OPEN  
Priority: Medium (defer until after current refactor stabilization)  
Owner: Unassigned (pick up when ready)  
Last Updated: 2025-08-21

## Summary
Foundational LLVM DWARF debug info scaffolding was added (compile unit, file, function `DISubprogram`, parameter variables, basic local declarations). A first pass of lexical scope stack support has been implemented (scope push/pop for control flow blocks). This issue tracks the remaining structured work to reach a solid Phase 4/5 DI baseline: correct lexical block nesting, consistent local variable emission, composite type (struct / sum / array / pointer / function) coverage, closure/coroutine DI, and regression tests that assert presence of critical `dbg.*` intrinsics and metadata.

## Current State (Implemented)
- Global enable via `EDN_ENABLE_DEBUG` env or build flag sets `DebugManager::enableDebugInfo`.
- Module flags + compile unit + synthetic file (overridable with `EDN_DEBUG_FILE` / `EDN_DEBUG_DIR`).
- Type DI caching for:
  - Base types (signed/unsigned/floating) with correct bit widths.
  - Pointer types (size & alignment via DataLayout helpers).
  - Struct types (member list built once bodies defined, includes offsets, sizes, alignments).
  - Arrays (subrange + alignment) and function types (subroutine types).
- Function attachment via `di::attach_function_debug` (creates `DISubprogram`).
- Parameter debug values via `di::emit_parameter_debug` (currently `dbg.value`).
- Local variable emission for `(as %var ...)` using `dbg.declare` on allocas.
- Added lexical scope stack (`DebugManager::scopeStack`) + push/pop instrumentation in `control_ops.cpp` for: if/then/else, while body, for body/step, switch case bodies, match case & default bodies.

## Gaps / Remaining Work
| Area | Gap | Desired Outcome |
|------|-----|-----------------|
| Lexical Blocks | Block lines always hard-coded to `1`; no original source line tracking | Propagate (or heuristically assign) line numbers from AST nodes / parsed metadata into `pushLexicalBlock` calls. |
| Locals API | `variable_ops` emits DI inline; `di::declare_local` not uniformly used | Centralize all local declarations through a single helper that decides between `dbg.declare` (alloca-backed) vs `dbg.value` (pure SSA). |
| Re-declared / shadowed names | No strategy for scopes with same variable name | Emit distinct `DILocalVariable` per scope and rely on lexical hierarchy. Add a test ensuring inner shadow hides outer in DWARF. |
| Closure Thunks | No DI for synthetic closure thunk functions or captured env | Attach `DISubprogram` to thunks; emit a parameter for the env pointer; optionally emit pseudo-variables for captured fields if decomposed. |
| Closure Structs | No member DI for closure structs that store function pointer + env | Model closure structs under a stable synthetic name (already created); ensure struct DI generation includes both fields. |
| Coroutines | (If enabled) lack coroutine-specific DI (suspend/resume points, frame vars) | At minimum emit subprogram + locals; consider marking suspension points by setting debug locations if coroutine lowering preserves them. |
| Sums / Match Binds | Binds create SSA values without DI entries | For each bound field, create a `dbg.value` in the case lexical block. |
| Composite Types Edge Cases | Union / sum layouts reused; ensure DI matches emitted IR (size/align/payload) | Validate union or sum payload size and alignment recorded correctly (add test). |
| Line Mapping | Most instructions use default or function line | Add a simple line propagation strategy (store line on parsed nodes or assign sequential pseudo-lines) to make DWARF less flat. |
| End of Function | `DIBuilder::finalize()` invoked via debug pipeline; ensure not double-called | Audit finalize timing (exactly once after IR emission, before passes / verification). |
| Tests | Only smoke + locals tests; no scope depth or struct member validation | Add granular tests (see below). |
| Tooling | No helper to dump summarized DWARF for tests | Provide a tiny DWARF summary utility (optional) or rely on pattern search of IR for `llvm.dbg.*` and metadata nodes. |

## Proposed Task Breakdown
1. Central Local Declaration
   - Add `declare_local` logic choosing declare vs value.
   - Replace inline emission in `variable_ops`, sum/match binds, and any future closure/coroutine locals.
2. Source Line Strategy (Minimal)
   - Introduce a monotonically increasing pseudo line counter in the emitter (or map EDN node indices to lines) to populate block and local line numbers.
   - Pass line to `pushLexicalBlock` and variable declarations.
3. Block Scope Instrumentation Completion
   - Add scopes for: for-loop condition, while condition (optional), match comparator block, lambda/closure bodies (if introduced), coroutine frame setup (optional).
4. Closure DI
   - Attach DI to thunk functions (name, return, params) and env param variable.
   - Optionally mark generated nature via `DW_AT_artificial` (set appropriate flags if supported by DIBuilder; else note as future).
5. Sum / Match Bind DI
   - Insert `dbg.value` for each variant field binding right after its load.
6. Coroutine DI (Phase 5 gating)
   - If coroutines enabled, ensure initial function scope and any frame locals declared before transformation (may rely on standard LLVM coroutine passes for final state).
7. Struct Member Verification Test
   - Ensure each struct member has a `DW_TAG_member` with expected offset and size.
8. Scope Nesting Test
   - Emit nested if/while/for and assert increasing chain of `DILexicalBlock` parents with correct depth.
9. Locals Shadowing Test
   - Two nested blocks redeclaring same `%x`; assert two distinct `DILocalVariable` metadata nodes.
10. Match Bind Test
    - Pattern match with multiple `bind` entries; assert `dbg.value` entries for each bound name.
11. Closure Debug Test (post-thunk DI)
    - Create closure + call; verify thunk has subprogram and env parameter appears as `llvm.dbg.value` or `dbg.declare`.
12. Documentation
    - Author `docs/DEBUG_INFO.md` summarizing EDN DI mapping rules (naming, scoping, which constructs get declare vs value).
13. Finalization Audit
    - Single `DIBuilder::finalize()` call in `debug_pipeline.cpp`; test re-entry safety.

## Acceptance Criteria
- All new tests pass: locals, scopes, struct members, match binds, closure DI.
- IR contains `llvm.dbg.declare` for all alloca-backed locals and `llvm.dbg.value` for all SSA-only temporaries chosen for exposure (at least params + match binds).
- Nested control constructs yield properly parented `DILexicalBlock` chain (depth tested â‰¥3).
- Struct member offsets in DWARF match DataLayout-derived offsets (spot check via metadata inspection).
- Closure thunk has a `DISubprogram` and at least one parameter variable recorded.
- No duplicate `DIBuilder::finalize()`; no missing finalize (verified by absence of unfrozen temporary nodes).
- Zero new warnings introduced (Clang -Wall/-Wextra baseline).

## Stretch / Future (Not Required to Close)
- Variable location updates after SSA promotion (post mem2reg) using `dbg.value` to track optimized values.
- DW_AT_artificial / DW_AT_linkage_name usage for synthesized thunks and internal temporaries.
- Inlined function DI (if/when higher-level inlining introduced in pass pipeline).
- Column information (currently all `1`).
- Precise line mapping from original EDN textual source when available.

## Risks & Mitigations
| Risk | Impact | Mitigation |
|------|--------|------------|
| Over-instrumentation bloats IR | Slower compile, noise | Keep DI insertion targeted (only user-visible names & match binds). |
| Incorrect offsets (struct/sum) | Misleading debuggers | Use DataLayout helpers exclusively; add regression tests. |
| Scope push/pop imbalance | Invalid metadata / crashes | RAII helper (optional) or careful structured push/pop pattern; add assertion in DebugManager (scopeStack never underflows). |
| Thunk DI confuses user | Debugger steps into synthetic frames unexpectedly | Mark artificial later; document current behavior. |

## Implementation Notes / Guidelines
- Prefer `dbg.declare` only when there is an address (& lifetime) to show; otherwise use `dbg.value`.
- For PHI-based SSA merges, optionally place a `dbg.value` after the PHI if value represents a user variable.
- Avoid creating empty lexical blocks; only push when emitting at least one instruction or variable.
- Keep `DebugManager` minimal: no heavy parsing logic; just scope and type caches.

## Test Ideas (Pseudo-EDN)
1. Nested Scopes:
```
(module (fn :name "nest" :ret void :params [] :body [
  (as %a i32 1)
  (if %cond [ (as %b i32 2) (while %cond2 [ (as %c i32 3) ]) ])
]))
```
Expect: a, b, c each in progressively deeper lexical blocks.

2. Match Binds:
```
(module (sum :name "OptI32" :variants [ (variant :name "Some" :fields [ i32 ]) (variant :name "None") ])
  (fn :name "use" :ret i32 :params [(param (ptr (struct OptI32)) %v)] :body [
     (match OptI32 %v :cases [ (case Some [ :binds [ (bind %x 0) ] :body [ (ret i32 %x) ]) ] :default [])
  ]) )
```
Expect: `dbg.value` for `%x` in case lexical block.

3. Closure Thunk (simplified pseudo) once closure DI active.

## Environment / Build Notes
Enable debug info via:
```
export EDN_ENABLE_DEBUG=1
ctest -R edn.phase4 -V --test-dir build
```
Implement tests under `tests/` with naming `phase4_debug_info_*_test.cpp` to integrate into existing phase harness.

## Dependencies / Ordering
- Safe to proceed after current refactor stabilization (EDN-0003) and sum ops ticket (EDN-0002) closure.
- Some tasks (coroutine DI) depend on coro feature maturity; can defer behind a feature flag.

## Definition of Done
All Acceptance Criteria met, PR merged, documentation (`docs/DEBUG_INFO.md`) added, and issue closed with a final summary referencing test names validating DI features.

## Initial Checklist
- [ ] Centralize local declaration helper
- [ ] Replace inline local DI emissions
- [ ] Add real line propagation (or pseudo-line counter)
- [ ] Complete lexical scope coverage (all control constructs)
- [ ] Match bind DI
- [ ] Closure thunk DI
- [ ] Struct member DI regression test
- [ ] Scopes depth regression test
- [ ] Shadowing regression test
- [ ] Finalize docs (DEBUG_INFO.md)
- [ ] Add summary & close

---
Created automatically during refactor pause to park outstanding DI work.
