// Clean implementation for type checker including blocks, assign, control flow
#pragma once
#include "type_check.hpp"

namespace edn {

inline void TypeChecker::error(TypeCheckResult& r, const node& n, std::string msg){ r.errors.push_back(TypeError{"EGEN", std::move(msg), "", line(n), col(n), {}}); }
inline void TypeChecker::warn(TypeCheckResult& r, const node& n, std::string msg){ r.warnings.push_back(TypeWarning{"WGEN", std::move(msg), "", line(n), col(n), {}}); }
inline void TypeChecker::error_code(TypeCheckResult& r, const node& n, std::string code, std::string msg, std::string hint){ r.errors.push_back(TypeError{std::move(code), std::move(msg), std::move(hint), line(n), col(n), {}}); }
inline void TypeChecker::reset(){ structs_.clear(); functions_.clear(); globals_.clear(); var_types_.clear(); }
inline void TypeChecker::collect_globals(TypeCheckResult& r, const std::vector<node_ptr>& elems){
    for(size_t i=1;i<elems.size(); ++i){
        auto &n = elems[i];
        if(!n||!std::holds_alternative<list>(n->data)) continue;
        auto &l=std::get<list>(n->data).elems;
        if(l.empty()||!std::holds_alternative<symbol>(l[0]->data)) continue;
        if(std::get<symbol>(l[0]->data).name!="global") continue;
        std::string name; TypeId ty=0; bool isConst=false; node_ptr init;
        for(size_t j=1;j<l.size(); ++j){
            if(l[j]&&std::holds_alternative<keyword>(l[j]->data)){
                std::string kw=std::get<keyword>(l[j]->data).name; if(++j>=l.size()) break; auto val=l[j];
                if(kw=="name" && std::holds_alternative<symbol>(val->data)) name=std::get<symbol>(val->data).name;
                else if(kw=="type") ty=parse_type_node(val,r);
                else if(kw=="const"){ if(std::holds_alternative<bool>(val->data)) isConst=std::get<bool>(val->data); }
                else if(kw=="init") init=val;
            }
        }
        if(name.empty()){ error(r,*n,"global missing :name"); r.success=false; continue;}
        if(!ty){ error(r,*n,"global missing :type"); r.success=false; continue;}
        if(globals_.count(name)){ error(r,*n,"duplicate global"); r.success=false; continue;}
        // Validation (M5): const/initializer semantic checks + aggregate literal validation.
        // Error code range E1220+ reserved for global const/data issues.
        if(init){
            const Type& T = ctx_.at(ty);
            auto emitInitError = [&](const std::string& code, const std::string& msg, const std::string& hint=""){ error_code(r,*n,code,msg,hint); r.success=false; };
            auto isIntLit=[&](const node_ptr& lit){ return lit && std::holds_alternative<int64_t>(lit->data); };
            auto isFloatLit=[&](const node_ptr& lit){ return lit && std::holds_alternative<double>(lit->data); };
            auto checkScalar=[&](BaseType b){ bool ok=false; if(is_integer_base(b)) ok = isIntLit(init); else if(is_float_base(b)) ok = isFloatLit(init) || isIntLit(init); if(!ok) emitInitError("E1220","global scalar initializer type mismatch","use literal matching declared global base type"); };
            if(T.kind==Type::Kind::Base){ checkScalar(T.base); }
            else if(T.kind==Type::Kind::Array){ if(!std::holds_alternative<vector_t>(init->data)){ emitInitError("E1221","global array initializer must be vector","wrap elements in [ ]"); }
                else {
                    auto &vec=std::get<vector_t>(init->data).elems; if(vec.size()!=T.array_size) emitInitError("E1222","array initializer length mismatch","provide exactly "+std::to_string(T.array_size)+" elements");
                    const Type& ET = ctx_.at(T.elem); if(ET.kind!=Type::Kind::Base){ emitInitError("E1223","array element type unsupported for const init","only base scalar elements supported"); }
                    else {
                        for(auto &e: vec){ if(!e){ emitInitError("E1223","array element missing","remove null element"); break; }
                            if(is_integer_base(ET.base)){ if(!isIntLit(e)) { emitInitError("E1223","array element literal type mismatch","use integer literal for element type"); break; } }
                            else if(is_float_base(ET.base)){ if(!(isFloatLit(e)||isIntLit(e))) { emitInitError("E1223","array element literal type mismatch","use float/int literal convertible to element type"); break; } }
                            else { emitInitError("E1223","array element type unsupported","use integer or float base type"); break; }
                        }
                    }
                }
            }
            else if(T.kind==Type::Kind::Struct){ if(!std::holds_alternative<vector_t>(init->data)){ emitInitError("E1224","global struct initializer must be vector","wrap field literals in [ ] in declared order"); }
                else {
                    auto sit = structs_.find(T.struct_name); if(sit==structs_.end()){ emitInitError("E1224","struct for initializer not declared","declare struct before global"); }
                    else {
                        auto &vec=std::get<vector_t>(init->data).elems; if(vec.size()!=sit->second.fields.size()) emitInitError("E1224","struct initializer field count mismatch","provide one literal per field");
                        else {
                            for(size_t fi=0; fi<vec.size() && fi<sit->second.fields.size(); ++fi){ auto &fld = sit->second.fields[fi]; const Type& FT = ctx_.at(fld.type); if(FT.kind!=Type::Kind::Base){ emitInitError("E1225","struct field type unsupported for const init","only base scalar fields supported"); break; }
                                auto lit = vec[fi]; if(is_integer_base(FT.base)){ if(!isIntLit(lit)) { emitInitError("E1225","struct field literal type mismatch","use integer literal"); break; } }
                                else if(is_float_base(FT.base)){ if(!(isFloatLit(lit)||isIntLit(lit))) { emitInitError("E1225","struct field literal type mismatch","use float/int literal convertible to field type"); break; } }
                                else { emitInitError("E1225","struct field type unsupported for const init","only integer/float base fields supported"); break; }
                            }
                        }
                    }
                }
            }
            else { emitInitError("E1228","unsupported global initializer kind","only base/array/struct types currently supported"); }
        }
        if(isConst && !init){ error_code(r,*n,"E1227","const global requires :init","add :init literal or aggregate vector"); r.success=false; }
        globals_[name]=GlobalInfoTC{name,ty,isConst,init};
    }
}
inline TypeId TypeChecker::parse_type_node(const node_ptr& n, TypeCheckResult& r){ try { return ctx_.parse_type(n); } catch(const parse_error& e){ r.success=false; error(r,*n,e.what()); return ctx_.get_base(BaseType::I32);} }
inline bool TypeChecker::parse_struct(TypeCheckResult& r, const node_ptr& n){ if(!n||!std::holds_alternative<list>(n->data)) return false; auto &l=std::get<list>(n->data).elems; if(l.empty()) return false; if(!std::holds_alternative<symbol>(l[0]->data)||std::get<symbol>(l[0]->data).name!="struct") return false; std::string name; std::vector<FieldInfo> fields; std::unordered_set<std::string> names; for(size_t i=1;i<l.size(); ++i){ if(!l[i]||!std::holds_alternative<keyword>(l[i]->data)) break; std::string kw=std::get<keyword>(l[i]->data).name; if(++i>=l.size()) break; auto val=l[i]; if(kw=="name"){ if(std::holds_alternative<symbol>(val->data)) name=std::get<symbol>(val->data).name; else if(std::holds_alternative<std::string>(val->data)) name=std::get<std::string>(val->data); else { r.success=false; error(r,*val,"struct :name expects symbol or string"); } } else if(kw=="fields"){ if(!val||!std::holds_alternative<vector_t>(val->data)){ r.success=false; error(r,*val,":fields expects vector"); continue; } auto &vec=std::get<vector_t>(val->data).elems; size_t idx=0; for(auto &f: vec){ if(!f||!std::holds_alternative<list>(f->data)){ r.success=false; error(r,*val,"field entry must be list"); continue; } auto &fl=std::get<list>(f->data).elems; std::string fname; TypeId fty=0; for(size_t k=0;k<fl.size(); ++k){ if(fl[k] && std::holds_alternative<keyword>(fl[k]->data)){ std::string fkw=std::get<keyword>(fl[k]->data).name; if(++k>=fl.size()) break; auto v=fl[k]; if(fkw=="name"){ if(std::holds_alternative<symbol>(v->data)) fname=std::get<symbol>(v->data).name; else { r.success=false; error(r,*v,"field :name expects symbol"); } } else if(fkw=="type"){ fty=parse_type_node(v,r); } } } if(fname.empty()){ r.success=false; error(r,*f,"field missing name"); continue;} if(names.count(fname)){ r.success=false; error(r,*f,"duplicate field"); continue;} names.insert(fname); fields.push_back(FieldInfo{fname,fty,idx++}); } } } if(name.empty()){ r.success=false; error(r,*n,"struct missing :name"); return true; } if(structs_.count(name)){ r.success=false; error(r,*n,"duplicate struct name"); } StructInfo si; si.name=name; si.fields=std::move(fields); for(auto &f: si.fields) si.field_map[f.name]=&f; structs_[name]=std::move(si); return true; }
inline bool TypeChecker::parse_function_header(TypeCheckResult& r, const node_ptr& fn, FunctionInfoTC& out_fn){ if(!fn||!std::holds_alternative<list>(fn->data)) return false; auto &fl=std::get<list>(fn->data).elems; if(fl.empty()) return false; if(!std::holds_alternative<symbol>(fl[0]->data)||std::get<symbol>(fl[0]->data).name!="fn") return false; std::string name; TypeId ret=ctx_.get_base(BaseType::Void); std::vector<ParamInfoTC> params; for(size_t i=1;i<fl.size(); ++i){ if(fl[i] && std::holds_alternative<keyword>(fl[i]->data)){ std::string kw=std::get<keyword>(fl[i]->data).name; if(++i>=fl.size()) break; auto val=fl[i]; if(kw=="name"){ if(std::holds_alternative<std::string>(val->data)) name=std::get<std::string>(val->data); } else if(kw=="ret"){ ret=parse_type_node(val,r); } else if(kw=="params"){ if(val && std::holds_alternative<vector_t>(val->data)){ for(auto &p: std::get<vector_t>(val->data).elems){ if(!p||!std::holds_alternative<list>(p->data)) continue; auto &pl=std::get<list>(p->data).elems; if(pl.size()==3 && std::holds_alternative<symbol>(pl[0]->data) && std::get<symbol>(pl[0]->data).name=="param"){ TypeId pty=parse_type_node(pl[1],r); std::string v; if(std::holds_alternative<symbol>(pl[2]->data)){ v=std::get<symbol>(pl[2]->data).name; if(!v.empty()&&v[0]=='%') v.erase(0,1);} params.push_back(ParamInfoTC{v,pty}); } } } } } } if(name.empty()){ r.success=false; error(r,*fn,"function missing :name"); } out_fn.name=name; out_fn.ret=ret; out_fn.params=std::move(params); return true; }
inline void TypeChecker::collect_structs(TypeCheckResult& r, const std::vector<node_ptr>& elems){ for(size_t i=1;i<elems.size(); ++i) parse_struct(r, elems[i]); }
inline void TypeChecker::collect_functions_headers(TypeCheckResult& r, const std::vector<node_ptr>& elems){ for(size_t i=1;i<elems.size(); ++i){ FunctionInfoTC fi; if(parse_function_header(r, elems[i], fi)){ if(functions_.count(fi.name)){ error(r,*elems[i],"duplicate function name"); r.success=false; } else functions_[fi.name]=fi; } } }
inline void TypeChecker::check_functions(TypeCheckResult& r, const std::vector<node_ptr>& elems){ for(size_t i=1;i<elems.size(); ++i){ auto &n=elems[i]; if(!n||!std::holds_alternative<list>(n->data)) continue; auto &fl=std::get<list>(n->data).elems; if(fl.empty()||!std::holds_alternative<symbol>(fl[0]->data) || std::get<symbol>(fl[0]->data).name!="fn") continue; std::string fname; for(size_t j=1;j<fl.size(); ++j){ if(fl[j] && std::holds_alternative<keyword>(fl[j]->data) && std::get<keyword>(fl[j]->data).name=="name"){ if(j+1<fl.size() && std::holds_alternative<std::string>(fl[j+1]->data)) fname=std::get<std::string>(fl[j+1]->data); } } if(fname.empty()) continue; auto it=functions_.find(fname); if(it!=functions_.end()) check_function_body(r,n,it->second); } }
inline void TypeChecker::check_function_body(TypeCheckResult& r, const node_ptr& fn, const FunctionInfoTC& info){ var_types_.clear(); for(auto &p: info.params) var_types_[p.name]=p.type; auto &fl=std::get<list>(fn->data).elems; node_ptr body; for(size_t i=1;i<fl.size(); ++i){ if(fl[i] && std::holds_alternative<keyword>(fl[i]->data) && std::get<keyword>(fl[i]->data).name=="body"){ if(++i<fl.size()) body=fl[i]; break; } } if(!body || !std::holds_alternative<vector_t>(body->data)){ error(r,*fn,":body missing or not vector"); r.success=false; return; } check_instruction_list(r, std::get<vector_t>(body->data).elems, info, 0); }
inline void TypeChecker::check_instruction_list(TypeCheckResult& r, const std::vector<node_ptr>& insts, const FunctionInfoTC& fn, int loop_depth){ auto get_var=[&](const std::string& n)->TypeId{ auto it=var_types_.find(n); return it==var_types_.end() ? (TypeId)-1 : it->second; }; auto attach=[&](const node_ptr& n, TypeId t){ n->metadata["type-id"]=detail::make_node((int64_t)t); }; auto is_int=[&](TypeId t){ const Type& T=ctx_.at(t); if(T.kind!=Type::Kind::Base) return false; switch(T.base){ case BaseType::I1: case BaseType::I8: case BaseType::I16: case BaseType::I32: case BaseType::I64: case BaseType::U8: case BaseType::U16: case BaseType::U32: case BaseType::U64: return true; default: return false;} }; for(auto &n: insts){ if(!n||!std::holds_alternative<list>(n->data)){ error(r,*n,"instruction must be list"); r.success=false; continue; } auto &il=std::get<list>(n->data).elems; if(il.empty()||!std::holds_alternative<symbol>(il[0]->data)){ error(r,*n,"instruction missing opcode"); r.success=false; continue; } std::string op=std::get<symbol>(il[0]->data).name; auto sym=[&](size_t i)->std::string{ if(i<il.size() && std::holds_alternative<symbol>(il[i]->data)) return std::get<symbol>(il[i]->data).name; return std::string{}; };
    if(op=="block"){ std::unordered_map<std::string,TypeId> saved=var_types_; for(size_t i=1;i<il.size(); ++i){ if(!il[i]||!std::holds_alternative<keyword>(il[i]->data)) break; std::string kw=std::get<keyword>(il[i]->data).name; if(++i>=il.size()) break; auto val=il[i]; if(kw=="locals"){ if(val && std::holds_alternative<vector_t>(val->data)){ for(auto &d: std::get<vector_t>(val->data).elems){ if(!d||!std::holds_alternative<list>(d->data)) continue; auto &dl=std::get<list>(d->data).elems; if(dl.size()==3 && std::holds_alternative<symbol>(dl[0]->data) && std::get<symbol>(dl[0]->data).name=="local"){ TypeId lty=parse_type_node(dl[1],r); if(std::holds_alternative<symbol>(dl[2]->data)){ std::string vn=std::get<symbol>(dl[2]->data).name; if(!vn.empty()&&vn[0]=='%') vn.erase(0,1); if(var_types_.count(vn)){ error(r,*d,"duplicate local"); r.success=false; } else var_types_[vn]=lty; } } } } } else if(kw=="body"){ if(val && std::holds_alternative<vector_t>(val->data)) check_instruction_list(r, std::get<vector_t>(val->data).elems, fn); } } var_types_=saved; continue; }
    if(op=="if"){ if(il.size()<3){ error_code(r,*n,"E1000","if arity","expected (if %cond [ then ] [ else ])"); r.success=false; continue; } std::string cond=sym(1); if(cond.empty()||cond[0] != '%'){ error_code(r,*n,"E1001","if cond must be %var","prefix condition with %"); r.success=false; continue; } auto ct=get_var(cond.substr(1)); if(ct!=(TypeId)-1){ const Type& T=ctx_.at(ct); if(!(T.kind==Type::Kind::Base && T.base==BaseType::I1)){ error_code(r,*n,"E1002","if cond must be i1","use boolean (i1) value"); r.success=false; } } if(il.size()>=3 && std::holds_alternative<vector_t>(il[2]->data)) check_instruction_list(r, std::get<vector_t>(il[2]->data).elems, fn); if(il.size()>=4 && std::holds_alternative<vector_t>(il[3]->data)) check_instruction_list(r, std::get<vector_t>(il[3]->data).elems, fn); continue; }
    if(op=="while"){ if(il.size()<3){ error_code(r,*n,"E1003","while arity","expected (while %cond [ body ])"); r.success=false; continue; } std::string cond=sym(1); if(cond.empty()||cond[0] != '%'){ error_code(r,*n,"E1004","while cond must be %var","prefix condition with %"); r.success=false; continue; } auto ct=get_var(cond.substr(1)); if(ct!=(TypeId)-1){ const Type& T=ctx_.at(ct); if(!(T.kind==Type::Kind::Base && T.base==BaseType::I1)){ error_code(r,*n,"E1005","while cond must be i1","use boolean (i1) value"); r.success=false; } } if(il.size()>=3 && std::holds_alternative<vector_t>(il[2]->data)) check_instruction_list(r, std::get<vector_t>(il[2]->data).elems, fn, loop_depth+1); continue; }
    if(op=="break"){ if(loop_depth==0){ error_code(r,*n,"E1006","break outside loop","use inside (while ...) body"); r.success=false; } if(il.size()!=1){ error_code(r,*n,"E1007","break takes no operands","remove extra tokens"); r.success=false; } continue; }
    if(op=="and"||op=="or"||op=="xor"||op=="shl"||op=="lshr"||op=="ashr"){ if(il.size()!=5){ error_code(r,*n,"E0600","bit/logical op arity","expected ("+op+" %dst <int-type> %a %b)"); r.success=false; continue; } std::string dst=sym(1), a=sym(3), b=sym(4); if(dst.empty()||a.empty()||b.empty()){ error_code(r,*n,"E0601","bit/logical expects symbols","use %dst %lhs %rhs"); r.success=false; continue; } TypeId ty=parse_type_node(il[2],r); if(ty==(TypeId)-1){ r.success=false; continue; } const Type& T=ctx_.at(ty); if(!(T.kind==Type::Kind::Base && (T.base==BaseType::I1||T.base==BaseType::I8||T.base==BaseType::I16||T.base==BaseType::I32||T.base==BaseType::I64))){ error_code(r,*n,"E0602","bit/logical op type must be integer","choose i1/i8/i16/i32/i64"); r.success=false; }
        auto check_operand=[&](const std::string& v){ if(v[0]=='%'){ auto vt=get_var(v.substr(1)); if(vt!=(TypeId)-1 && vt!=ty){ error_code(r,*n,"E0603","operand type mismatch","operands must match annotated type"); r.success=false; } } else { error_code(r,*n,"E0604","operand must be %var","prefix with %"); r.success=false; } };
        check_operand(a); check_operand(b); if(dst[0]=='%'){ if(var_types_.count(dst.substr(1))){ error_code(r,*n,"E0605","redefinition of variable","rename destination"); r.success=false; } var_types_[dst.substr(1)]=ty; attach(n,ty);} else { error_code(r,*n,"E0606","dest must be %var","prefix destination with %"); r.success=false; } continue; }
    if(op=="fadd"||op=="fsub"||op=="fmul"||op=="fdiv"){ if(il.size()!=5){ error_code(r,*n,"E0700","fbinop arity","expected ("+op+" %dst <float-type> %a %b)"); r.success=false; continue; } std::string dst=sym(1),a=sym(3),b=sym(4); if(dst.empty()||a.empty()||b.empty()){ error_code(r,*n,"E0701","fbinop symbol expected","use % for dst and operands"); r.success=false; continue; } TypeId ty=parse_type_node(il[2],r); const Type& T=ctx_.at(ty); if(!(T.kind==Type::Kind::Base && (T.base==BaseType::F32||T.base==BaseType::F64))){ error_code(r,*n,"E0702","fbinop type must be f32/f64","choose f32 or f64"); r.success=false; }
        if(a[0]=='%'){ auto at=get_var(a.substr(1)); if(at!=(TypeId)-1 && at!=ty){ error_code(r,*n,"E0703","lhs type mismatch","lhs must match annotated type"); r.success=false; } }
        if(b[0]=='%'){ auto bt=get_var(b.substr(1)); if(bt!=(TypeId)-1 && bt!=ty){ error_code(r,*n,"E0704","rhs type mismatch","rhs must match annotated type"); r.success=false; } }
        if(dst[0]=='%'){ if(var_types_.count(dst.substr(1))){ error_code(r,*n,"E0705","redefinition of variable","rename destination"); r.success=false; } var_types_[dst.substr(1)]=ty; attach(n,ty);} else { error_code(r,*n,"E0706","dest must be %var","prefix destination with %"); r.success=false; } continue; }
    if(op=="add"||op=="sub"||op=="mul"||op=="sdiv"||op=="udiv"||op=="srem"||op=="urem"){ if(il.size()!=5){ error_code(r,*n,"E0001","binop arity","expected ("+op+" %dst <int-type> %a %b)"); r.success=false; continue; } std::string dst=sym(1),a=sym(3),b=sym(4); if(dst.empty()||a.empty()||b.empty()){ error_code(r,*n,"E0002","binop symbol expected","use %prefix on destination and operands e.g. %x"); r.success=false; continue; } TypeId ty=parse_type_node(il[2],r); if(!is_int(ty)){ error_code(r,*n,"E0003","binop type must be integer","choose one of i1/i8/i16/i32/i64/u8/u16/u32/u64"); r.success=false; } if(a[0]=='%'){ auto at=get_var(a.substr(1)); if(at!=(TypeId)-1 && at!=ty){ error_code(r,*n,"E0004","lhs type mismatch","lhs must have same type as annotated binop type"); r.success=false; } } if(b[0]=='%'){ auto bt=get_var(b.substr(1)); if(bt!=(TypeId)-1 && bt!=ty){ error_code(r,*n,"E0005","rhs type mismatch","rhs must have same type as annotated binop type"); r.success=false; } } if(dst[0]=='%'){ if(var_types_.count(dst.substr(1))){ error_code(r,*n,"E0006","redefinition of variable","rename destination to fresh SSA name"); r.success=false; } var_types_[dst.substr(1)]=ty; attach(n,ty);} else { error_code(r,*n,"E0007","dest must be %var","prepend % to create SSA name"); r.success=false; } continue; }
    if(op=="eq"||op=="ne"||op=="lt"||op=="gt"||op=="le"||op=="ge"){ if(const char* warnEnv = std::getenv("EDN_WARN_DEPRECATED")){ if(warnEnv[0]=='1') warn(r,*n,"legacy comparison op '"+op+"' deprecated; use (icmp %dst <type> :pred <pred>)"); } if(il.size()!=5){ error_code(r,*n,"E0100","cmp arity","expected ("+op+" %dst <int-type> %a %b)"); r.success=false; continue; } std::string dst=sym(1),a=sym(3),b=sym(4); if(dst.empty()||a.empty()||b.empty()){ error_code(r,*n,"E0101","cmp symbol expected","supply %dst %lhs %rhs"); r.success=false; continue; } TypeId opty=parse_type_node(il[2],r); if(!is_int(opty)){ error_code(r,*n,"E0102","cmp operand type must be integer","use integer base type"); r.success=false; } auto check_operand=[&](const std::string& v){ if(v[0]=='%'){ auto vt=get_var(v.substr(1)); if(vt!=(TypeId)-1 && vt!=opty){ error_code(r,*n,"E0103","cmp operand type mismatch","make both operands the same type as annotated comparison type"); r.success=false; } } else { error_code(r,*n,"E0104","operand must be %var","precede variable with %"); r.success=false; } }; check_operand(a); check_operand(b); if(dst[0]=='%'){ if(var_types_.count(dst.substr(1))){ error_code(r,*n,"E0105","redefinition of variable","rename destination"); r.success=false; } TypeId rty=ctx_.get_base(BaseType::I1); var_types_[dst.substr(1)]=rty; attach(n,rty);} else { error_code(r,*n,"E0106","dest must be %var","precede destination with %"); r.success=false; } continue; }
    if(op=="icmp"){ if(il.size()!=7){ error_code(r,*n,"E0110","icmp arity","expected (icmp %dst <int-type> :pred <pred> %a %b)"); r.success=false; continue; } std::string dst=sym(1); if(dst.empty()||dst[0] != '%'){ error_code(r,*n,"E0111","icmp dst must be %var","prefix destination with %"); r.success=false; continue; } TypeId opty=parse_type_node(il[2],r); if(!is_int(opty)){ error_code(r,*n,"E0112","icmp operand type must be integer","choose integer type"); r.success=false; } if(!il[3]||!std::holds_alternative<keyword>(il[3]->data) || std::get<keyword>(il[3]->data).name!="pred"){ error_code(r,*n,"E0113","icmp expects :pred keyword","insert :pred before predicate symbol"); r.success=false; continue; } std::string pred=sym(4); static const std::unordered_set<std::string> preds{"eq","ne","slt","sgt","sle","sge","ult","ugt","ule","uge"}; if(!preds.count(pred)){ error_code(r,*n,"E0114","unknown icmp predicate","use one of eq/ne/slt/sgt/sle/sge/ult/ugt/ule/uge"); r.success=false; } std::string a=sym(5), b=sym(6); if(a.empty()||b.empty()){ error_code(r,*n,"E0115","icmp operands required","supply %lhs %rhs"); r.success=false; continue; } auto check_operand=[&](const std::string& v){ if(v[0]=='%'){ auto vt=get_var(v.substr(1)); if(vt!=(TypeId)-1 && vt!=opty){ error_code(r,*n,"E0116","icmp operand type mismatch","operand types must match annotated type"); r.success=false; } } else { error_code(r,*n,"E0117","icmp operand must be %var","prefix operand with %"); r.success=false; } }; check_operand(a); check_operand(b); if(var_types_.count(dst.substr(1))){ error_code(r,*n,"E0118","redefinition of variable","rename destination"); r.success=false; } TypeId rty=ctx_.get_base(BaseType::I1); var_types_[dst.substr(1)]=rty; attach(n,rty); continue; }
    // Cast instructions (Phase 2) with coded diagnostics
    if(op=="zext"||op=="sext"||op=="trunc"||op=="bitcast"||op=="sitofp"||op=="uitofp"||op=="fptosi"||op=="fptoui"||op=="ptrtoint"||op=="inttoptr"){
        if(il.size()!=4){ error_code(r,*n,"E0500", op+" arity","expected ("+op+" %dst <to-type> %src)"); r.success=false; continue; }
        std::string dst=sym(1); if(dst.empty()||dst[0] != '%'){ error_code(r,*n,"E0504","cast dst must be %var","prefix destination with %"); r.success=false; continue; }
        TypeId toTy=parse_type_node(il[2],r); std::string src=sym(3); if(src.empty()||src[0] != '%'){ error_code(r,*n,"E0501", op+" src must be %var","prefix source with %"); r.success=false; continue; }
        auto st=get_var(src.substr(1)); if(st==(TypeId)-1){ error_code(r,*n,"E0502","unknown cast source var","define source earlier"); r.success=false; continue; }
        const Type& TO=ctx_.at(toTy); const Type& FROM=ctx_.at(st);
        auto bad=[&](const std::string& msg, const std::string& hint){ error_code(r,*n,"E0508",msg,hint); r.success=false; };
        auto width=[&](TypeId t)->unsigned{ const Type& TT=ctx_.at(t); if(TT.kind!=Type::Kind::Base) return 0; return base_type_bit_width(TT.base); };
        if(op=="zext"||op=="sext"||op=="trunc"){
            if(FROM.kind!=Type::Kind::Base || TO.kind!=Type::Kind::Base || !is_integer_base(FROM.base) || !is_integer_base(TO.base)) bad("int cast requires integer types","both from/to must be integer base types");
            else {
                unsigned fw=width(st), tw=width(toTy); if(fw==0||tw==0||fw==tw) bad("width change required","choose different bit width");
                else if(op=="zext"||op=="sext"){ if(!(tw>fw)) bad("extension must increase width","target width > source width"); if(op=="sext" && !is_signed_base(FROM.base)) bad("sext requires signed source","use signed integer source"); }
                else if(op=="trunc" && !(fw>tw)) bad("trunc must reduce width","source width > target width");
            }
        } else if(op=="bitcast"){
            bool ok=false; if(FROM.kind==Type::Kind::Pointer && TO.kind==Type::Kind::Pointer) ok=true; else if(FROM.kind==Type::Kind::Base && TO.kind==Type::Kind::Base){ unsigned fw=width(st), tw=width(toTy); ok = (fw==tw && fw!=0); }
            if(!ok) bad("invalid bitcast types","same bit width scalars or pointer->pointer only");
        } else if(op=="sitofp"||op=="uitofp"){
            if(FROM.kind!=Type::Kind::Base || TO.kind!=Type::Kind::Base || !is_integer_base(FROM.base) || !is_float_base(TO.base)) bad("int->float cast types invalid","from integer to float");
            else if(op=="sitofp" && !is_signed_base(FROM.base)) bad("sitofp requires signed int source","use signed integer");
        } else if(op=="fptosi"||op=="fptoui"){
            if(FROM.kind!=Type::Kind::Base || TO.kind!=Type::Kind::Base || !is_float_base(FROM.base) || !is_integer_base(TO.base)) bad("float->int cast types invalid","from float to integer");
            else if(op=="fptosi" && !is_signed_base(TO.base)) bad("fptosi requires signed int destination","target must be signed integer");
        } else if(op=="ptrtoint"){
            if(FROM.kind!=Type::Kind::Pointer || TO.kind!=Type::Kind::Base || !is_integer_base(TO.base)) bad("ptrtoint requires pointer -> integer","source pointer, target integer");
            else { unsigned tw=width(toTy); if(!(tw==64 || tw==32)) bad("ptrtoint integer width must match pointer size (assume 64/32)","use i64 or i32"); }
        } else if(op=="inttoptr"){
            if(FROM.kind!=Type::Kind::Base || TO.kind!=Type::Kind::Pointer || !is_integer_base(FROM.base)) bad("inttoptr requires integer -> pointer","source integer, target pointer");
            else { unsigned fw=width(st); if(!(fw==64 || fw==32)) bad("inttoptr integer width must match pointer size (assume 64/32)","use i64 or i32"); }
        }
        if(var_types_.count(dst.substr(1))){ error_code(r,*n,"E0505","redefinition of variable","rename destination"); r.success=false; }
        var_types_[dst.substr(1)]=toTy; attach(n,toTy); continue;
    }
    if(op=="fcmp"){ if(il.size()!=7){ error_code(r,*n,"E0120","fcmp arity","expected (fcmp %dst <float-type> :pred <pred> %a %b)"); r.success=false; continue; } std::string dst=sym(1); if(dst.empty()||dst[0] != '%'){ error_code(r,*n,"E0121","fcmp dst must be %var","prefix destination with %"); r.success=false; continue; } TypeId opty=parse_type_node(il[2],r); const Type& T=ctx_.at(opty); if(!(T.kind==Type::Kind::Base && (T.base==BaseType::F32||T.base==BaseType::F64))){ error_code(r,*n,"E0122","fcmp operand type must be float","use f32 or f64"); r.success=false; }
        if(!il[3]||!std::holds_alternative<keyword>(il[3]->data) || std::get<keyword>(il[3]->data).name!="pred"){ error_code(r,*n,"E0123","fcmp expects :pred keyword","insert :pred before predicate"); r.success=false; continue; }
        std::string pred=sym(4); static const std::unordered_set<std::string> fpreds{"oeq","one","olt","ogt","ole","oge"}; if(!fpreds.count(pred)){ error_code(r,*n,"E0124","unknown fcmp predicate","use one of oeq/one/olt/ogt/ole/oge"); r.success=false; }
        std::string a=sym(5), b=sym(6); if(a.empty()||b.empty()){ error_code(r,*n,"E0125","fcmp operands required","supply %lhs %rhs"); r.success=false; continue; }
        auto check_operand=[&](const std::string& v){ if(v[0]=='%'){ auto vt=get_var(v.substr(1)); if(vt!=(TypeId)-1 && vt!=opty){ error_code(r,*n,"E0126","fcmp operand type mismatch","operands must match annotated type"); r.success=false; } } else { error_code(r,*n,"E0127","fcmp operand must be %var","prefix operand with %"); r.success=false; } }; check_operand(a); check_operand(b);
        if(var_types_.count(dst.substr(1))){ error_code(r,*n,"E0128","redefinition of variable","rename destination"); r.success=false; }
        TypeId rty=ctx_.get_base(BaseType::I1); var_types_[dst.substr(1)]=rty; attach(n,rty); continue; }
    if(op=="const"){ if(il.size()!=4){ error_code(r,*n,"E1100","const arity","expected (const %dst <type> <literal>)"); r.success=false; continue; } std::string dst=sym(1); if(dst.empty()||dst[0] != '%'){ error_code(r,*n,"E1101","const dst must be %var","prefix destination with %"); r.success=false; continue; } if(var_types_.count(dst.substr(1))){ error_code(r,*n,"E1102","redefinition of variable","rename destination"); r.success=false; } TypeId ty=parse_type_node(il[2],r); var_types_[dst.substr(1)]=ty; attach(n,ty); continue; }
    if(op=="assign"){ if(il.size()!=3){ error_code(r,*n,"E1103","assign arity","expected (assign %dst %src)"); r.success=false; continue; } std::string v=sym(1), src=sym(2); if(v.empty()||v[0] != '%'){ error_code(r,*n,"E1104","assign target must be %var","prefix target with %"); r.success=false; continue; } if(src.empty()||src[0] != '%'){ error_code(r,*n,"E1105","assign src must be %var","prefix source with %"); r.success=false; continue; } auto vt=get_var(v.substr(1)); if(vt==(TypeId)-1){ error_code(r,*n,"E1106","unknown target var","define destination earlier"); r.success=false; continue; } auto st=get_var(src.substr(1)); if(st!=(TypeId)-1 && st!=vt){ error_code(r,*n,"E1107","assign type mismatch","types of %dst and %src must match"); r.success=false; } continue; }
    if(op=="ret"){ if(il.size()!=3){ error_code(r,*n,"E1010","ret arity","expected (ret <type> %val)"); r.success=false; continue; } TypeId ty=parse_type_node(il[1],r); if(ty!=fn.ret){ error_code(r,*n,"E1011","return type mismatch","match function declared :ret type"); r.success=false; } std::string val=sym(2); if(!val.empty()&&val[0]=='%'){ auto vt=get_var(val.substr(1)); if(vt!=(TypeId)-1 && vt!=ty){ error_code(r,*n,"E1012","return value type mismatch","value must have return type"); r.success=false; } } continue; }
    if(op=="member"){ if(il.size()!=5){ error_code(r,*n,"E0800","member arity","expected (member %dst Struct %base %field)"); r.success=false; continue; } std::string dst=sym(1), stName=sym(2), base=sym(3), field=sym(4); if(dst.empty()||stName.empty()||base.empty()||field.empty()){ error_code(r,*n,"E0801","member expects symbols","supply %dst StructName %base %field"); r.success=false; continue; } auto sit=structs_.find(stName); if(sit==structs_.end()){ error_code(r,*n,"E0802","unknown struct in member","declare struct before use"); r.success=false; continue; } auto fit=sit->second.field_map.find(field); if(fit==sit->second.field_map.end()){ error_code(r,*n,"E0803","unknown field","check struct field spelling"); r.success=false; continue; } if(base[0]=='%'){ auto bt=get_var(base.substr(1)); if(bt==(TypeId)-1){ error_code(r,*n,"E0804","base undefined","define base variable first"); r.success=false; } else { const Type& BT=ctx_.at(bt); bool ok=false; if(BT.kind==Type::Kind::Struct && BT.struct_name==stName) ok=true; else if(BT.kind==Type::Kind::Pointer){ const Type& PT=ctx_.at(BT.pointee); if(PT.kind==Type::Kind::Struct && PT.struct_name==stName) ok=true; } if(!ok){ error_code(r,*n,"E0805","base not struct or pointer to struct","use (struct-ref Name) or pointer"); r.success=false; } } } else { error_code(r,*n,"E0806","base must be %var","prefix with %"); r.success=false; }
        if(dst[0]=='%'){ if(var_types_.count(dst.substr(1))){ error_code(r,*n,"E0808","redefinition of variable","rename destination"); r.success=false; } var_types_[dst.substr(1)]=fit->second->type; attach(n, fit->second->type);} else { error_code(r,*n,"E0807","member dst must be %var","prefix destination with %"); r.success=false; } continue; }
    if(op=="member-addr"){ if(il.size()!=5){ error_code(r,*n,"E0810","member-addr arity","expected (member-addr %dst Struct %base %field)"); r.success=false; continue; } std::string dst=sym(1), stName=sym(2), base=sym(3), field=sym(4); if(dst.empty()||stName.empty()||base.empty()||field.empty()){ error_code(r,*n,"E0811","member-addr expects symbols","supply %dst StructName %base %field"); r.success=false; continue; } auto sit=structs_.find(stName); if(sit==structs_.end()){ error_code(r,*n,"E0812","unknown struct in member-addr","declare struct before use"); r.success=false; continue; } auto fit=sit->second.field_map.find(field); if(fit==sit->second.field_map.end()){ error_code(r,*n,"E0813","unknown field","check field name"); r.success=false; continue; } if(base[0]=='%'){ auto bt=get_var(base.substr(1)); if(bt==(TypeId)-1){ error_code(r,*n,"E0814","base undefined","define base variable first"); r.success=false; } else { const Type& BT=ctx_.at(bt); bool ok=false; if(BT.kind==Type::Kind::Pointer){ const Type& PT=ctx_.at(BT.pointee); if(PT.kind==Type::Kind::Struct && PT.struct_name==stName) ok=true; } if(!ok){ error_code(r,*n,"E0815","member-addr base must be pointer to struct","pass pointer (e.g. param (ptr (struct-ref S)))"); r.success=false; } } } else { error_code(r,*n,"E0816","base must be %var","prefix with %"); r.success=false; }
        if(dst[0]=='%'){ if(var_types_.count(dst.substr(1))){ error_code(r,*n,"E0818","redefinition of variable","rename destination"); r.success=false; } TypeId pty=ctx_.get_pointer(fit->second->type); var_types_[dst.substr(1)]=pty; attach(n, pty);} else { error_code(r,*n,"E0817","member-addr dst must be %var","prefix destination with %"); r.success=false; } continue; }
    if(op=="load"){ if(il.size()!=4){ error_code(r,*n,"E0200","load arity","expected (load %dst <type> %ptr)"); r.success=false; continue; } std::string dst=sym(1), ptr=sym(3); if(dst.empty()||ptr.empty()){ error_code(r,*n,"E0201","load symbols","supply %dst and %ptr"); r.success=false; continue; } TypeId ty=parse_type_node(il[2],r); if(ptr[0]=='%'){ auto pt=get_var(ptr.substr(1)); if(pt==(TypeId)-1){ error_code(r,*n,"E0202","ptr undefined","define pointer variable before load"); r.success=false; } else { const Type& PT=ctx_.at(pt); if(PT.kind!=Type::Kind::Pointer || PT.pointee!=ty){ error_code(r,*n,"E0203","ptr not pointer to type","pointer must be (ptr <type>)"); r.success=false; } } } if(dst[0]=='%'){ var_types_[dst.substr(1)]=ty; attach(n,ty);} else { error_code(r,*n,"E0204","load dst must be %var","prefix destination with %"); r.success=false; } continue; }
    if(op=="store"){ if(il.size()!=4){ error_code(r,*n,"E0210","store arity","expected (store <type> %ptr %val)"); r.success=false; continue; } TypeId ty=parse_type_node(il[1],r); std::string ptr=sym(2), val=sym(3); if(ptr.empty()||val.empty()){ error_code(r,*n,"E0211","store symbols","provide %ptr and %val"); r.success=false; continue; } if(ptr[0]=='%'){ auto pt=get_var(ptr.substr(1)); if(pt==(TypeId)-1){ error_code(r,*n,"E0212","ptr undefined","define pointer before store"); r.success=false; } else { const Type& PT=ctx_.at(pt); if(PT.kind!=Type::Kind::Pointer || PT.pointee!=ty){ error_code(r,*n,"E0213","store ptr type mismatch","pointer pointee must match <type>"); r.success=false; } } } if(val[0]=='%'){ auto vt=get_var(val.substr(1)); if(vt!=(TypeId)-1 && vt!=ty){ error_code(r,*n,"E0214","store value type mismatch","value must match <type>"); r.success=false; } } continue; }
    if(op=="gload"){ if(il.size()!=4){ error_code(r,*n,"E0900","gload arity","expected (gload %dst <type> GlobalName)"); r.success=false; continue;} std::string dst=sym(1), gname=sym(3); if(dst.empty()||gname.empty()){ error_code(r,*n,"E0901","gload symbols","supply %dst and global name"); r.success=false; continue;} TypeId ty=parse_type_node(il[2],r); GlobalInfoTC* gi=nullptr; if(!lookup_global(gname,gi)){ error_code(r,*n,"E0902","unknown global","declare (global :name ...)"); r.success=false; } else if(gi->type!=ty){ error_code(r,*n,"E0903","gload type mismatch","use declared global type"); r.success=false; } if(dst[0]=='%'){ if(var_types_.count(dst.substr(1))){ error_code(r,*n,"E0905","redefinition of variable","rename destination"); r.success=false;} var_types_[dst.substr(1)]=ty; attach(n,ty);} else { error_code(r,*n,"E0904","gload dst must be %var","prefix destination with %"); r.success=false;} continue; }
    if(op=="gstore"){ if(il.size()!=4){ error_code(r,*n,"E0910","gstore arity","expected (gstore <type> GlobalName %val)"); r.success=false; continue;} TypeId ty=parse_type_node(il[1],r); std::string gname=sym(2), val=sym(3); if(gname.empty()||val.empty()){ error_code(r,*n,"E0911","gstore symbols","provide global name and %val"); r.success=false; continue;} GlobalInfoTC* gi=nullptr; if(!lookup_global(gname,gi)){ error_code(r,*n,"E0912","unknown global","declare (global :name ...)"); r.success=false; } else {
            if(gi->type!=ty){ error_code(r,*n,"E0913","gstore type mismatch","use global's declared type"); r.success=false; }
            if(gi->is_const){ error_code(r,*n,"E1226","cannot store to const global","remove :const or avoid mutation"); r.success=false; }
        }
        if(val[0]=='%'){ auto vt=get_var(val.substr(1)); if(vt!=(TypeId)-1 && vt!=ty){ error_code(r,*n,"E0914","gstore value type mismatch","value must match <type>"); r.success=false; } } else { error_code(r,*n,"E0915","gstore value must be %var","prefix value with %"); r.success=false; } continue; }
    if(op=="index"){ if(il.size()!=5){ error_code(r,*n,"E0820","index arity","expected (index %dst <elem-type> %basePtr %idx)"); r.success=false; continue; } std::string dst=sym(1), base=sym(3), idx=sym(4); if(dst.empty()||base.empty()||idx.empty()){ error_code(r,*n,"E0821","index symbols","supply %dst %base %idx"); r.success=false; continue; } TypeId elem=parse_type_node(il[2],r); if(base[0]=='%'){ auto bt=get_var(base.substr(1)); if(bt==(TypeId)-1){ error_code(r,*n,"E0822","base undefined","define base pointer earlier"); r.success=false; } else { const Type& BT=ctx_.at(bt); if(BT.kind!=Type::Kind::Pointer){ error_code(r,*n,"E0823","index base not pointer","use pointer to array"); r.success=false; } else { const Type& AT=ctx_.at(BT.pointee); if(AT.kind!=Type::Kind::Array || AT.elem!=elem){ error_code(r,*n,"E0824","base not pointer to array elem type","ensure pointer pointee matches (array :elem <elem-type>)"); r.success=false; } } } } if(idx[0]=='%'){ auto it=get_var(idx.substr(1)); if(it!=(TypeId)-1 && !is_int(it)){ error_code(r,*n,"E0825","index must be int","index variable must be integer type"); r.success=false; } } if(dst[0]=='%'){ if(var_types_.count(dst.substr(1))){ error_code(r,*n,"E0827","redefinition of variable","rename destination"); r.success=false; } var_types_[dst.substr(1)]=ctx_.get_pointer(elem); attach(n, ctx_.get_pointer(elem)); } else { error_code(r,*n,"E0826","index dst must be %var","prefix destination with %"); r.success=false; } continue; }
    if(op=="alloca"){ if(il.size()!=3){ error_code(r,*n,"E1108","alloca arity","expected (alloca %dst <type>)"); r.success=false; continue; } std::string dst=sym(1); if(dst.empty()||dst[0] != '%'){ error_code(r,*n,"E1109","alloca dst must be %var","prefix destination with %"); r.success=false; continue; } TypeId ty=parse_type_node(il[2],r); if(var_types_.count(dst.substr(1))){ error_code(r,*n,"E1110","redefinition of variable","rename destination"); r.success=false; } TypeId pty=ctx_.get_pointer(ty); var_types_[dst.substr(1)]=pty; attach(n,pty); continue; }
    if(op=="struct-lit"){ if(il.size()!=4){ error_code(r,*n,"E1200","struct-lit arity","expected (struct-lit %dst StructName [ field1 %v1 ... ])"); r.success=false; continue; } std::string dst=sym(1), stName=sym(2); if(dst.empty()||stName.empty()){ error_code(r,*n,"E1201","struct-lit symbols","supply %dst StructName [ ... ]"); r.success=false; continue; } auto sit=structs_.find(stName); if(sit==structs_.end()){ error_code(r,*n,"E1202","unknown struct","declare struct before literal"); r.success=false; continue; } if(!il[3]||!std::holds_alternative<vector_t>(il[3]->data)){ error_code(r,*n,"E1203","struct-lit fields must be vector","wrap field list in [ ]"); r.success=false; continue; } auto &vec=std::get<vector_t>(il[3]->data).elems; // expect pairs name %var in declared order
        if(vec.size()!=sit->second.fields.size()*2){ error_code(r,*n,"E1204","struct-lit field count mismatch","provide name/value pairs for all fields"); r.success=false; }
        bool orderOk=true; size_t fi=0; for(size_t i=0;i<vec.size(); i+=2,++fi){ if(fi>=sit->second.fields.size()) break; if(!vec[i]||!std::holds_alternative<symbol>(vec[i]->data)){ error_code(r,*n,"E1205","field name must be symbol","use declared field names"); r.success=false; orderOk=false; break; } std::string fname=std::get<symbol>(vec[i]->data).name; if(fname!=sit->second.fields[fi].name){ error_code(r,*n,"E1206","field order/name mismatch","use declared order"); r.success=false; orderOk=false; }
            if(i+1>=vec.size()||!vec[i+1]||!std::holds_alternative<symbol>(vec[i+1]->data)){ error_code(r,*n,"E1207","field value must be %var symbol","prefix with %"); r.success=false; orderOk=false; continue; } std::string val=std::get<symbol>(vec[i+1]->data).name; if(val.empty()||val[0] != '%'){ error_code(r,*n,"E1207","field value must be %var symbol","prefix with %"); r.success=false; orderOk=false; continue; } auto vt=get_var(val.substr(1)); if(vt!=(TypeId)-1 && vt!=sit->second.fields[fi].type){ error_code(r,*n,"E1208","field value type mismatch","match struct field type"); r.success=false; }
        }
        if(dst[0]=='%'){ if(var_types_.count(dst.substr(1))){ error_code(r,*n,"E1209","redefinition of variable","rename destination"); r.success=false; } TypeId sty=ctx_.get_struct(stName); TypeId pty=ctx_.get_pointer(sty); var_types_[dst.substr(1)]=pty; attach(n,pty);} else { error_code(r,*n,"E1201","struct-lit symbols","destination must be %var"); r.success=false; } continue; }
    if(op=="array-lit"){ if(il.size()!=5){ error_code(r,*n,"E1210","array-lit arity","expected (array-lit %dst <elem-type> <size> [ %e0 %e1 ... ])"); r.success=false; continue; } std::string dst=sym(1); if(dst.empty()||dst[0] != '%'){ error_code(r,*n,"E1211","array-lit dst must be %var","prefix destination with %"); r.success=false; continue; } TypeId elem=parse_type_node(il[2],r); if(!il[3]||!std::holds_alternative<int64_t>(il[3]->data)){ error_code(r,*n,"E1212","array-lit size int","size must be integer literal"); r.success=false; continue; } uint64_t asz=(uint64_t)std::get<int64_t>(il[3]->data); if(asz==0){ error_code(r,*n,"E1213","array size > 0","use positive size"); r.success=false; }
        if(!il[4]||!std::holds_alternative<vector_t>(il[4]->data)){ error_code(r,*n,"E1214","array-lit elems must be vector","wrap elements in [ ]"); r.success=false; continue; } auto &elems=std::get<vector_t>(il[4]->data).elems; if(elems.size()!=asz){ error_code(r,*n,"E1215","array-lit count mismatch","element count must equal declared size"); r.success=false; }
        for(auto &e: elems){ if(!e||!std::holds_alternative<symbol>(e->data)){ error_code(r,*n,"E1216","array elem must be %var","prefix each element with %"); r.success=false; continue; } std::string v=std::get<symbol>(e->data).name; if(v.empty()||v[0] != '%'){ error_code(r,*n,"E1216","array elem must be %var","prefix each element with %"); r.success=false; continue; } auto vt=get_var(v.substr(1)); if(vt!=(TypeId)-1 && vt!=elem){ error_code(r,*n,"E1217","array elem type mismatch","match <elem-type>"); r.success=false; } }
        if(var_types_.count(dst.substr(1))){ error_code(r,*n,"E1218","redefinition of variable","rename destination"); r.success=false; } TypeId aty=ctx_.get_array(elem, asz); TypeId pty=ctx_.get_pointer(aty); var_types_[dst.substr(1)]=pty; attach(n,pty); continue; }
    if(op=="phi"){ // (phi %dst <type> [ (%val %label) ... ])
        if(il.size()!=4){ error_code(r,*n,"E0300","phi arity","expected (phi %dst <type> [ (%v %label) ... ])"); r.success=false; continue; }
        std::string dst=sym(1); if(dst.empty()||dst[0] != '%'){ error_code(r,*n,"E0301","phi dst must be %var","use %name for SSA value"); r.success=false; continue; }
        if(var_types_.count(dst.substr(1))){ error_code(r,*n,"E0302","redefinition of variable","rename phi destination"); r.success=false; continue; }
        TypeId ty=parse_type_node(il[2],r);
        if(!il[3] || !std::holds_alternative<vector_t>(il[3]->data)){ error_code(r,*n,"E0303","phi incoming list must be vector","wrap incoming pairs in [ ... ]"); r.success=false; continue; }
        auto &incVec = std::get<vector_t>(il[3]->data).elems; if(incVec.size()<2){ error_code(r,*n,"E0304","phi requires at least two incoming values","provide at least two (%val %label) pairs"); r.success=false; }
        for(auto &inc : incVec){ if(!inc || !std::holds_alternative<list>(inc->data)){ error_code(r,*n,"E0305","phi incoming entry must be list","form is (%val %label)"); r.success=false; continue; } auto &pl = std::get<list>(inc->data).elems; if(pl.size()!=2){ error_code(r,*inc,"E0306","phi incoming entry arity","need exactly (%val %label)"); r.success=false; continue; } if(!std::holds_alternative<symbol>(pl[0]->data) || !std::holds_alternative<symbol>(pl[1]->data)){ error_code(r,*inc,"E0307","phi incoming expects (%val %label)",""); r.success=false; continue; } std::string v = std::get<symbol>(pl[0]->data).name; if(v.empty()||v[0] != '%'){ error_code(r,*inc,"E0308","phi incoming value must be %var","prefix with %"); r.success=false; continue; } auto vt = get_var(v.substr(1)); if(vt!=(TypeId)-1 && vt!=ty){ error_code(r,*inc,"E0309","phi incoming value type mismatch","match all incoming value types to phi type"); r.success=false; } }
        var_types_[dst.substr(1)] = ty; attach(n,ty); continue; }
    if(op=="call"){ if(il.size()<4){ error_code(r,*n,"E0400","call arity","expected (call %dst <ret-type> name %args...) "); r.success=false; continue; } std::string dst=sym(1); if(dst.empty()||dst[0] != '%'){ error_code(r,*n,"E0401","call dst must be %var","prefix destination with %"); r.success=false; continue; } TypeId ret=parse_type_node(il[2],r); std::string callee=sym(3); if(callee.empty()){ error_code(r,*n,"E0402","call callee symbol required","supply function name after return type"); r.success=false; continue; } FunctionInfoTC* finfo=nullptr; if(!lookup_function(callee, finfo)){ error_code(r,*n,"E0403","unknown callee","define function first"); r.success=false; } if(finfo && ret!=finfo->ret){ error_code(r,*n,"E0404","call return type mismatch","callee returns different type"); r.success=false; } if(finfo){ size_t expected=finfo->params.size(); size_t provided= (il.size()>4)? il.size()-4:0; if(provided!=expected){ error_code(r,*n,"E0405","call arg count mismatch","expected "+std::to_string(expected)+" got "+std::to_string(provided)); r.success=false; } else { for(size_t ai=0; ai<provided; ++ai){ std::string av=sym(4+ai); if(av.empty()||av[0] != '%'){ error_code(r,*n,"E0406","call arg must be %var","prefix each arg with %"); r.success=false; continue; } auto at=get_var(av.substr(1)); if(at==(TypeId)-1){ error_code(r,*n,"E0407","unknown arg var","define arg value earlier"); r.success=false; continue; } if(at!=finfo->params[ai].type){ error_code(r,*n,"E0408","call arg type mismatch","match declared param type"); r.success=false; } } } } var_types_[dst.substr(1)]=ret; attach(n,ret); continue; }
    error(r,*n,"unknown instruction"); r.success=false; }
}
inline TypeCheckResult TypeChecker::check_module(const node_ptr& m){ TypeCheckResult res{true,{},{}}; if(!m||!std::holds_alternative<list>(m->data)){ res.success=false; res.errors.push_back(TypeError{"EMOD1","module not list","",-1,-1,{}}); return res; } auto &l=std::get<list>(m->data).elems; if(l.empty()||!std::holds_alternative<symbol>(l[0]->data) || std::get<symbol>(l[0]->data).name!="module"){ res.success=false; res.errors.push_back(TypeError{"EMOD2","expected (module ...)","start file with (module ...)",-1,-1,{}}); return res; } reset(); collect_structs(res,l); collect_globals(res,l); collect_functions_headers(res,l); if(res.success) check_functions(res,l); return res; }

} // namespace edn
