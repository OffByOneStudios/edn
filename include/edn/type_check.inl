// Clean implementation for type checker including blocks, assign, control flow
#pragma once
#include "type_check.hpp"

namespace edn {

inline void TypeChecker::error(TypeCheckResult& r, const node& n, std::string msg){ r.errors.push_back(TypeError{std::move(msg), line(n), col(n)}); }
inline void TypeChecker::reset(){ structs_.clear(); functions_.clear(); var_types_.clear(); }
inline void TypeChecker::collect_globals(TypeCheckResult& r, const std::vector<node_ptr>& elems){ for(size_t i=1;i<elems.size(); ++i){ auto &n = elems[i]; if(!n||!std::holds_alternative<list>(n->data)) continue; auto &l=std::get<list>(n->data).elems; if(l.empty()||!std::holds_alternative<symbol>(l[0]->data)) continue; if(std::get<symbol>(l[0]->data).name!="global") continue; std::string name; TypeId ty=0; for(size_t j=1;j<l.size(); ++j){ if(l[j]&&std::holds_alternative<keyword>(l[j]->data)){ std::string kw=std::get<keyword>(l[j]->data).name; if(++j>=l.size()) break; auto val=l[j]; if(kw=="name" && std::holds_alternative<symbol>(val->data)) name=std::get<symbol>(val->data).name; else if(kw=="type") ty=parse_type_node(val,r); }} if(name.empty()){ error(r,*n,"global missing :name"); r.success=false; continue;} if(!ty){ error(r,*n,"global missing :type"); r.success=false; continue;} if(globals_.count(name)){ error(r,*n,"duplicate global"); r.success=false; continue;} globals_[name]=GlobalInfoTC{name,ty}; } }
inline TypeId TypeChecker::parse_type_node(const node_ptr& n, TypeCheckResult& r){ try { return ctx_.parse_type(n); } catch(const parse_error& e){ r.success=false; error(r,*n,e.what()); return ctx_.get_base(BaseType::I32);} }
inline bool TypeChecker::parse_struct(TypeCheckResult& r, const node_ptr& n){ if(!n||!std::holds_alternative<list>(n->data)) return false; auto &l=std::get<list>(n->data).elems; if(l.empty()) return false; if(!std::holds_alternative<symbol>(l[0]->data)||std::get<symbol>(l[0]->data).name!="struct") return false; std::string name; std::vector<FieldInfo> fields; std::unordered_set<std::string> names; for(size_t i=1;i<l.size(); ++i){ if(!l[i]||!std::holds_alternative<keyword>(l[i]->data)) break; std::string kw=std::get<keyword>(l[i]->data).name; if(++i>=l.size()) break; auto val=l[i]; if(kw=="name"){ if(std::holds_alternative<symbol>(val->data)) name=std::get<symbol>(val->data).name; else if(std::holds_alternative<std::string>(val->data)) name=std::get<std::string>(val->data); else { r.success=false; error(r,*val,"struct :name expects symbol or string"); } } else if(kw=="fields"){ if(!val||!std::holds_alternative<vector_t>(val->data)){ r.success=false; error(r,*val,":fields expects vector"); continue; } auto &vec=std::get<vector_t>(val->data).elems; size_t idx=0; for(auto &f: vec){ if(!f||!std::holds_alternative<list>(f->data)){ r.success=false; error(r,*val,"field entry must be list"); continue; } auto &fl=std::get<list>(f->data).elems; std::string fname; TypeId fty=0; for(size_t k=0;k<fl.size(); ++k){ if(fl[k] && std::holds_alternative<keyword>(fl[k]->data)){ std::string fkw=std::get<keyword>(fl[k]->data).name; if(++k>=fl.size()) break; auto v=fl[k]; if(fkw=="name"){ if(std::holds_alternative<symbol>(v->data)) fname=std::get<symbol>(v->data).name; else { r.success=false; error(r,*v,"field :name expects symbol"); } } else if(fkw=="type"){ fty=parse_type_node(v,r); } } } if(fname.empty()){ r.success=false; error(r,*f,"field missing name"); continue;} if(names.count(fname)){ r.success=false; error(r,*f,"duplicate field"); continue;} names.insert(fname); fields.push_back(FieldInfo{fname,fty,idx++}); } } } if(name.empty()){ r.success=false; error(r,*n,"struct missing :name"); return true; } if(structs_.count(name)){ r.success=false; error(r,*n,"duplicate struct name"); } StructInfo si; si.name=name; si.fields=std::move(fields); for(auto &f: si.fields) si.field_map[f.name]=&f; structs_[name]=std::move(si); return true; }
inline bool TypeChecker::parse_function_header(TypeCheckResult& r, const node_ptr& fn, FunctionInfoTC& out_fn){ if(!fn||!std::holds_alternative<list>(fn->data)) return false; auto &fl=std::get<list>(fn->data).elems; if(fl.empty()) return false; if(!std::holds_alternative<symbol>(fl[0]->data)||std::get<symbol>(fl[0]->data).name!="fn") return false; std::string name; TypeId ret=ctx_.get_base(BaseType::Void); std::vector<ParamInfoTC> params; for(size_t i=1;i<fl.size(); ++i){ if(fl[i] && std::holds_alternative<keyword>(fl[i]->data)){ std::string kw=std::get<keyword>(fl[i]->data).name; if(++i>=fl.size()) break; auto val=fl[i]; if(kw=="name"){ if(std::holds_alternative<std::string>(val->data)) name=std::get<std::string>(val->data); } else if(kw=="ret"){ ret=parse_type_node(val,r); } else if(kw=="params"){ if(val && std::holds_alternative<vector_t>(val->data)){ for(auto &p: std::get<vector_t>(val->data).elems){ if(!p||!std::holds_alternative<list>(p->data)) continue; auto &pl=std::get<list>(p->data).elems; if(pl.size()==3 && std::holds_alternative<symbol>(pl[0]->data) && std::get<symbol>(pl[0]->data).name=="param"){ TypeId pty=parse_type_node(pl[1],r); std::string v; if(std::holds_alternative<symbol>(pl[2]->data)){ v=std::get<symbol>(pl[2]->data).name; if(!v.empty()&&v[0]=='%') v.erase(0,1);} params.push_back(ParamInfoTC{v,pty}); } } } } } } if(name.empty()){ r.success=false; error(r,*fn,"function missing :name"); } out_fn.name=name; out_fn.ret=ret; out_fn.params=std::move(params); return true; }
inline void TypeChecker::collect_structs(TypeCheckResult& r, const std::vector<node_ptr>& elems){ for(size_t i=1;i<elems.size(); ++i) parse_struct(r, elems[i]); }
inline void TypeChecker::collect_functions_headers(TypeCheckResult& r, const std::vector<node_ptr>& elems){ for(size_t i=1;i<elems.size(); ++i){ FunctionInfoTC fi; if(parse_function_header(r, elems[i], fi)){ if(functions_.count(fi.name)){ error(r,*elems[i],"duplicate function name"); r.success=false; } else functions_[fi.name]=fi; } } }
inline void TypeChecker::check_functions(TypeCheckResult& r, const std::vector<node_ptr>& elems){ for(size_t i=1;i<elems.size(); ++i){ auto &n=elems[i]; if(!n||!std::holds_alternative<list>(n->data)) continue; auto &fl=std::get<list>(n->data).elems; if(fl.empty()||!std::holds_alternative<symbol>(fl[0]->data) || std::get<symbol>(fl[0]->data).name!="fn") continue; std::string fname; for(size_t j=1;j<fl.size(); ++j){ if(fl[j] && std::holds_alternative<keyword>(fl[j]->data) && std::get<keyword>(fl[j]->data).name=="name"){ if(j+1<fl.size() && std::holds_alternative<std::string>(fl[j+1]->data)) fname=std::get<std::string>(fl[j+1]->data); } } if(fname.empty()) continue; auto it=functions_.find(fname); if(it!=functions_.end()) check_function_body(r,n,it->second); } }
inline void TypeChecker::check_function_body(TypeCheckResult& r, const node_ptr& fn, const FunctionInfoTC& info){ var_types_.clear(); for(auto &p: info.params) var_types_[p.name]=p.type; auto &fl=std::get<list>(fn->data).elems; node_ptr body; for(size_t i=1;i<fl.size(); ++i){ if(fl[i] && std::holds_alternative<keyword>(fl[i]->data) && std::get<keyword>(fl[i]->data).name=="body"){ if(++i<fl.size()) body=fl[i]; break; } } if(!body || !std::holds_alternative<vector_t>(body->data)){ error(r,*fn,":body missing or not vector"); r.success=false; return; } check_instruction_list(r, std::get<vector_t>(body->data).elems, info, 0); }
inline void TypeChecker::check_instruction_list(TypeCheckResult& r, const std::vector<node_ptr>& insts, const FunctionInfoTC& fn, int loop_depth){ auto get_var=[&](const std::string& n)->TypeId{ auto it=var_types_.find(n); return it==var_types_.end() ? (TypeId)-1 : it->second; }; auto attach=[&](const node_ptr& n, TypeId t){ n->metadata["type-id"]=detail::make_node((int64_t)t); }; auto is_int=[&](TypeId t){ const Type& T=ctx_.at(t); if(T.kind!=Type::Kind::Base) return false; switch(T.base){ case BaseType::I1: case BaseType::I8: case BaseType::I16: case BaseType::I32: case BaseType::I64: case BaseType::U8: case BaseType::U16: case BaseType::U32: case BaseType::U64: return true; default: return false;} }; for(auto &n: insts){ if(!n||!std::holds_alternative<list>(n->data)){ error(r,*n,"instruction must be list"); r.success=false; continue; } auto &il=std::get<list>(n->data).elems; if(il.empty()||!std::holds_alternative<symbol>(il[0]->data)){ error(r,*n,"instruction missing opcode"); r.success=false; continue; } std::string op=std::get<symbol>(il[0]->data).name; auto sym=[&](size_t i)->std::string{ if(i<il.size() && std::holds_alternative<symbol>(il[i]->data)) return std::get<symbol>(il[i]->data).name; return std::string{}; };
    if(op=="block"){ std::unordered_map<std::string,TypeId> saved=var_types_; for(size_t i=1;i<il.size(); ++i){ if(!il[i]||!std::holds_alternative<keyword>(il[i]->data)) break; std::string kw=std::get<keyword>(il[i]->data).name; if(++i>=il.size()) break; auto val=il[i]; if(kw=="locals"){ if(val && std::holds_alternative<vector_t>(val->data)){ for(auto &d: std::get<vector_t>(val->data).elems){ if(!d||!std::holds_alternative<list>(d->data)) continue; auto &dl=std::get<list>(d->data).elems; if(dl.size()==3 && std::holds_alternative<symbol>(dl[0]->data) && std::get<symbol>(dl[0]->data).name=="local"){ TypeId lty=parse_type_node(dl[1],r); if(std::holds_alternative<symbol>(dl[2]->data)){ std::string vn=std::get<symbol>(dl[2]->data).name; if(!vn.empty()&&vn[0]=='%') vn.erase(0,1); if(var_types_.count(vn)){ error(r,*d,"duplicate local"); r.success=false; } else var_types_[vn]=lty; } } } } } else if(kw=="body"){ if(val && std::holds_alternative<vector_t>(val->data)) check_instruction_list(r, std::get<vector_t>(val->data).elems, fn); } } var_types_=saved; continue; }
    if(op=="if"){ if(il.size()<3){ error(r,*n,"if arity"); r.success=false; continue; } std::string cond=sym(1); if(cond.empty()||cond[0] != '%'){ error(r,*n,"if cond must be %var"); r.success=false; continue; } auto ct=get_var(cond.substr(1)); if(ct!=(TypeId)-1){ const Type& T=ctx_.at(ct); if(!(T.kind==Type::Kind::Base && T.base==BaseType::I1)){ error(r,*n,"if cond must be i1"); r.success=false; } } if(il.size()>=3 && std::holds_alternative<vector_t>(il[2]->data)) check_instruction_list(r, std::get<vector_t>(il[2]->data).elems, fn); if(il.size()>=4 && std::holds_alternative<vector_t>(il[3]->data)) check_instruction_list(r, std::get<vector_t>(il[3]->data).elems, fn); continue; }
    if(op=="while"){ if(il.size()<3){ error(r,*n,"while arity"); r.success=false; continue; } std::string cond=sym(1); if(cond.empty()||cond[0] != '%'){ error(r,*n,"while cond must be %var"); r.success=false; continue; } auto ct=get_var(cond.substr(1)); if(ct!=(TypeId)-1){ const Type& T=ctx_.at(ct); if(!(T.kind==Type::Kind::Base && T.base==BaseType::I1)){ error(r,*n,"while cond must be i1"); r.success=false; } } if(il.size()>=3 && std::holds_alternative<vector_t>(il[2]->data)) check_instruction_list(r, std::get<vector_t>(il[2]->data).elems, fn, loop_depth+1); continue; }
    if(op=="break"){ if(loop_depth==0){ error(r,*n,"break outside loop"); r.success=false; } if(il.size()!=1){ error(r,*n,"break takes no operands"); r.success=false; } continue; }
    if(op=="and"||op=="or"||op=="xor"||op=="shl"||op=="lshr"||op=="ashr"){ if(il.size()!=5){ error(r,*n,"bit/logical op arity"); r.success=false; continue; } std::string dst=sym(1), a=sym(3), b=sym(4); if(dst.empty()||a.empty()||b.empty()){ error(r,*n,"bit/logical expects symbols"); r.success=false; continue; } TypeId ty=parse_type_node(il[2],r); // restrict to integer (i1..i64)
        if(ty==(TypeId)-1){ r.success=false; continue; }
        const Type& T=ctx_.at(ty); if(!(T.kind==Type::Kind::Base && (T.base==BaseType::I1||T.base==BaseType::I8||T.base==BaseType::I16||T.base==BaseType::I32||T.base==BaseType::I64))){ error(r,*n,"bit/logical op type must be integer"); r.success=false; }
        auto check_operand=[&](const std::string& v){ if(v[0]=='%'){ auto vt=get_var(v.substr(1)); if(vt!=(TypeId)-1 && vt!=ty){ error(r,*n,"operand type mismatch"); r.success=false; } } else { error(r,*n,"operand must be %var"); r.success=false; } };
        check_operand(a); check_operand(b); if(dst[0]=='%'){ if(var_types_.count(dst.substr(1))){ error(r,*n,"redefinition of variable"); r.success=false; } var_types_[dst.substr(1)]=ty; attach(n,ty);} else { error(r,*n,"dest must be %var"); r.success=false; } continue; }
    if(op=="fadd"||op=="fsub"||op=="fmul"||op=="fdiv"){ if(il.size()!=5){ error(r,*n,"fbinop arity"); r.success=false; continue; } std::string dst=sym(1),a=sym(3),b=sym(4); if(dst.empty()||a.empty()||b.empty()){ error(r,*n,"fbinop symbol expected"); r.success=false; continue; } TypeId ty=parse_type_node(il[2],r); const Type& T=ctx_.at(ty); if(!(T.kind==Type::Kind::Base && (T.base==BaseType::F32||T.base==BaseType::F64))){ error(r,*n,"fbinop type must be f32/f64"); r.success=false; }
        if(a[0]=='%'){ auto at=get_var(a.substr(1)); if(at!=(TypeId)-1 && at!=ty){ error(r,*n,"lhs type mismatch"); r.success=false; } }
        if(b[0]=='%'){ auto bt=get_var(b.substr(1)); if(bt!=(TypeId)-1 && bt!=ty){ error(r,*n,"rhs type mismatch"); r.success=false; } }
        if(dst[0]=='%'){ if(var_types_.count(dst.substr(1))){ error(r,*n,"redefinition of variable"); r.success=false; } var_types_[dst.substr(1)]=ty; attach(n,ty);} else { error(r,*n,"dest must be %var"); r.success=false; } continue; }
    if(op=="add"||op=="sub"||op=="mul"||op=="sdiv"||op=="udiv"||op=="srem"||op=="urem"){ if(il.size()!=5){ error(r,*n,"binop arity"); r.success=false; continue; } std::string dst=sym(1),a=sym(3),b=sym(4); if(dst.empty()||a.empty()||b.empty()){ error(r,*n,"binop symbol expected"); r.success=false; continue; } TypeId ty=parse_type_node(il[2],r); if(!is_int(ty)){ error(r,*n,"binop type must be integer"); r.success=false; } if(a[0]=='%'){ auto at=get_var(a.substr(1)); if(at!=(TypeId)-1 && at!=ty){ error(r,*n,"lhs type mismatch"); r.success=false; } } if(b[0]=='%'){ auto bt=get_var(b.substr(1)); if(bt!=(TypeId)-1 && bt!=ty){ error(r,*n,"rhs type mismatch"); r.success=false; } } if(dst[0]=='%'){ if(var_types_.count(dst.substr(1))){ error(r,*n,"redefinition of variable"); r.success=false; } var_types_[dst.substr(1)]=ty; attach(n,ty);} else { error(r,*n,"dest must be %var"); r.success=false; } continue; }
    if(op=="eq"||op=="ne"||op=="lt"||op=="gt"||op=="le"||op=="ge"){ if(il.size()!=5){ error(r,*n,"cmp arity"); r.success=false; continue; } std::string dst=sym(1),a=sym(3),b=sym(4); if(dst.empty()||a.empty()||b.empty()){ error(r,*n,"cmp symbol expected"); r.success=false; continue; } TypeId opty=parse_type_node(il[2],r); if(!is_int(opty)){ error(r,*n,"cmp operand type must be integer"); r.success=false; } auto check_operand=[&](const std::string& v){ if(v[0]=='%'){ auto vt=get_var(v.substr(1)); if(vt!=(TypeId)-1 && vt!=opty){ error(r,*n,"cmp operand type mismatch"); r.success=false; } } else { error(r,*n,"operand must be %var"); r.success=false; } }; check_operand(a); check_operand(b); if(dst[0]=='%'){ if(var_types_.count(dst.substr(1))){ error(r,*n,"redefinition of variable"); r.success=false; } TypeId rty=ctx_.get_base(BaseType::I1); var_types_[dst.substr(1)]=rty; attach(n,rty);} else { error(r,*n,"dest must be %var"); r.success=false; } continue; }
    if(op=="icmp"){ if(il.size()!=7){ error(r,*n,"icmp arity"); r.success=false; continue; } std::string dst=sym(1); if(dst.empty()||dst[0] != '%'){ error(r,*n,"icmp dst must be %var"); r.success=false; continue; } TypeId opty=parse_type_node(il[2],r); if(!is_int(opty)){ error(r,*n,"icmp operand type must be integer"); r.success=false; } if(!il[3]||!std::holds_alternative<keyword>(il[3]->data) || std::get<keyword>(il[3]->data).name!="pred"){ error(r,*n,"icmp expects :pred keyword"); r.success=false; continue; } std::string pred=sym(4); static const std::unordered_set<std::string> preds{"eq","ne","slt","sgt","sle","sge","ult","ugt","ule","uge"}; if(!preds.count(pred)){ error(r,*n,"unknown icmp predicate"); r.success=false; } std::string a=sym(5), b=sym(6); if(a.empty()||b.empty()){ error(r,*n,"icmp operands required"); r.success=false; continue; } auto check_operand=[&](const std::string& v){ if(v[0]=='%'){ auto vt=get_var(v.substr(1)); if(vt!=(TypeId)-1 && vt!=opty){ error(r,*n,"icmp operand type mismatch"); r.success=false; } } else { error(r,*n,"icmp operand must be %var"); r.success=false; } }; check_operand(a); check_operand(b); if(var_types_.count(dst.substr(1))){ error(r,*n,"redefinition of variable"); r.success=false; } TypeId rty=ctx_.get_base(BaseType::I1); var_types_[dst.substr(1)]=rty; attach(n,rty); continue; }
    if(op=="fcmp"){ if(il.size()!=7){ error(r,*n,"fcmp arity"); r.success=false; continue; } std::string dst=sym(1); if(dst.empty()||dst[0] != '%'){ error(r,*n,"fcmp dst must be %var"); r.success=false; continue; } TypeId opty=parse_type_node(il[2],r); const Type& T=ctx_.at(opty); if(!(T.kind==Type::Kind::Base && (T.base==BaseType::F32||T.base==BaseType::F64))){ error(r,*n,"fcmp operand type must be float"); r.success=false; }
        if(!il[3]||!std::holds_alternative<keyword>(il[3]->data) || std::get<keyword>(il[3]->data).name!="pred"){ error(r,*n,"fcmp expects :pred keyword"); r.success=false; continue; }
        std::string pred=sym(4); static const std::unordered_set<std::string> fpreds{"oeq","one","olt","ogt","ole","oge"}; if(!fpreds.count(pred)){ error(r,*n,"unknown fcmp predicate"); r.success=false; }
        std::string a=sym(5), b=sym(6); if(a.empty()||b.empty()){ error(r,*n,"fcmp operands required"); r.success=false; continue; }
        auto check_operand=[&](const std::string& v){ if(v[0]=='%'){ auto vt=get_var(v.substr(1)); if(vt!=(TypeId)-1 && vt!=opty){ error(r,*n,"fcmp operand type mismatch"); r.success=false; } } else { error(r,*n,"fcmp operand must be %var"); r.success=false; } }; check_operand(a); check_operand(b);
        if(var_types_.count(dst.substr(1))){ error(r,*n,"redefinition of variable"); r.success=false; }
        TypeId rty=ctx_.get_base(BaseType::I1); var_types_[dst.substr(1)]=rty; attach(n,rty); continue; }
    if(op=="const"){ if(il.size()!=4){ error(r,*n,"const arity"); r.success=false; continue; } std::string dst=sym(1); if(dst.empty()||dst[0] != '%'){ error(r,*n,"const dst must be %var"); r.success=false; continue; } if(var_types_.count(dst.substr(1))){ error(r,*n,"redefinition of variable"); r.success=false; } TypeId ty=parse_type_node(il[2],r); var_types_[dst.substr(1)]=ty; attach(n,ty); continue; }
    if(op=="assign"){ if(il.size()!=3){ error(r,*n,"assign arity"); r.success=false; continue; } std::string v=sym(1), src=sym(2); if(v.empty()||v[0] != '%'){ error(r,*n,"assign target must be %var"); r.success=false; continue; } if(src.empty()||src[0] != '%'){ error(r,*n,"assign src must be %var"); r.success=false; continue; } auto vt=get_var(v.substr(1)); if(vt==(TypeId)-1){ error(r,*n,"unknown target var"); r.success=false; continue; } auto st=get_var(src.substr(1)); if(st!=(TypeId)-1 && st!=vt){ error(r,*n,"assign type mismatch"); r.success=false; } continue; }
    if(op=="ret"){ if(il.size()!=3){ error(r,*n,"ret arity"); r.success=false; continue; } TypeId ty=parse_type_node(il[1],r); if(ty!=fn.ret){ error(r,*n,"return type mismatch"); r.success=false; } std::string val=sym(2); if(!val.empty()&&val[0]=='%'){ auto vt=get_var(val.substr(1)); if(vt!=(TypeId)-1 && vt!=ty){ error(r,*n,"return value type mismatch"); r.success=false; } } continue; }
    if(op=="member"){ if(il.size()!=5){ error(r,*n,"member arity"); r.success=false; continue; } std::string dst=sym(1), stName=sym(2), base=sym(3), field=sym(4); if(dst.empty()||stName.empty()||base.empty()||field.empty()){ error(r,*n,"member expects symbols"); r.success=false; continue; } auto sit=structs_.find(stName); if(sit==structs_.end()){ error(r,*n,"unknown struct in member"); r.success=false; continue; } auto fit=sit->second.field_map.find(field); if(fit==sit->second.field_map.end()){ error(r,*n,"unknown field"); r.success=false; continue; } if(base[0]=='%'){ auto bt=get_var(base.substr(1)); if(bt==(TypeId)-1){ error(r,*n,"base undefined"); r.success=false; } else { const Type& BT=ctx_.at(bt); bool ok=false; if(BT.kind==Type::Kind::Struct && BT.struct_name==stName) ok=true; else if(BT.kind==Type::Kind::Pointer){ const Type& PT=ctx_.at(BT.pointee); if(PT.kind==Type::Kind::Struct && PT.struct_name==stName) ok=true; } if(!ok){ error(r,*n,"base not struct or pointer to struct"); r.success=false; } } } else { error(r,*n,"base must be %var"); r.success=false; }
        if(dst[0]=='%'){ var_types_[dst.substr(1)]=fit->second->type; attach(n, fit->second->type);} else { error(r,*n,"member dst must be %var"); r.success=false; } continue; }
    if(op=="member-addr"){ if(il.size()!=5){ error(r,*n,"member-addr arity"); r.success=false; continue; } std::string dst=sym(1), stName=sym(2), base=sym(3), field=sym(4); if(dst.empty()||stName.empty()||base.empty()||field.empty()){ error(r,*n,"member-addr expects symbols"); r.success=false; continue; } auto sit=structs_.find(stName); if(sit==structs_.end()){ error(r,*n,"unknown struct in member-addr"); r.success=false; continue; } auto fit=sit->second.field_map.find(field); if(fit==sit->second.field_map.end()){ error(r,*n,"unknown field"); r.success=false; continue; } if(base[0]=='%'){ auto bt=get_var(base.substr(1)); if(bt==(TypeId)-1){ error(r,*n,"base undefined"); r.success=false; } else { const Type& BT=ctx_.at(bt); bool ok=false; if(BT.kind==Type::Kind::Pointer){ const Type& PT=ctx_.at(BT.pointee); if(PT.kind==Type::Kind::Struct && PT.struct_name==stName) ok=true; } if(!ok){ error(r,*n,"member-addr base must be pointer to struct"); r.success=false; } } } else { error(r,*n,"base must be %var"); r.success=false; }
        if(dst[0]=='%'){ TypeId pty=ctx_.get_pointer(fit->second->type); var_types_[dst.substr(1)]=pty; attach(n, pty);} else { error(r,*n,"member-addr dst must be %var"); r.success=false; } continue; }
    if(op=="load"){ if(il.size()!=4){ error(r,*n,"load arity"); r.success=false; continue; } std::string dst=sym(1), ptr=sym(3); if(dst.empty()||ptr.empty()){ error(r,*n,"load symbols"); r.success=false; continue; } TypeId ty=parse_type_node(il[2],r); if(ptr[0]=='%'){ auto pt=get_var(ptr.substr(1)); if(pt==(TypeId)-1){ error(r,*n,"ptr undefined"); r.success=false; } else { const Type& PT=ctx_.at(pt); if(PT.kind!=Type::Kind::Pointer || PT.pointee!=ty){ error(r,*n,"ptr not pointer to type"); r.success=false; } } } if(dst[0]=='%'){ var_types_[dst.substr(1)]=ty; attach(n,ty);} else { error(r,*n,"load dst must be %var"); r.success=false; } continue; }
    if(op=="store"){ if(il.size()!=4){ error(r,*n,"store arity"); r.success=false; continue; } TypeId ty=parse_type_node(il[1],r); std::string ptr=sym(2), val=sym(3); if(ptr.empty()||val.empty()){ error(r,*n,"store symbols"); r.success=false; continue; } if(ptr[0]=='%'){ auto pt=get_var(ptr.substr(1)); if(pt==(TypeId)-1){ error(r,*n,"ptr undefined"); r.success=false; } else { const Type& PT=ctx_.at(pt); if(PT.kind!=Type::Kind::Pointer || PT.pointee!=ty){ error(r,*n,"store ptr type mismatch"); r.success=false; } } } if(val[0]=='%'){ auto vt=get_var(val.substr(1)); if(vt!=(TypeId)-1 && vt!=ty){ error(r,*n,"store value type mismatch"); r.success=false; } } continue; }
    if(op=="gload"){ if(il.size()!=4){ error(r,*n,"gload arity"); r.success=false; continue;} std::string dst=sym(1), gname=sym(3); if(dst.empty()||gname.empty()){ error(r,*n,"gload symbols"); r.success=false; continue;} TypeId ty=parse_type_node(il[2],r); GlobalInfoTC* gi=nullptr; if(!lookup_global(gname,gi)){ error(r,*n,"unknown global"); r.success=false; } else if(gi->type!=ty){ error(r,*n,"gload type mismatch"); r.success=false; } if(dst[0]=='%'){ if(var_types_.count(dst.substr(1))){ error(r,*n,"redefinition of variable"); r.success=false;} var_types_[dst.substr(1)]=ty; attach(n,ty);} else { error(r,*n,"gload dst must be %var"); r.success=false;} continue; }
    if(op=="gstore"){ if(il.size()!=4){ error(r,*n,"gstore arity"); r.success=false; continue;} TypeId ty=parse_type_node(il[1],r); std::string gname=sym(2), val=sym(3); if(gname.empty()||val.empty()){ error(r,*n,"gstore symbols"); r.success=false; continue;} GlobalInfoTC* gi=nullptr; if(!lookup_global(gname,gi)){ error(r,*n,"unknown global"); r.success=false; } else if(gi->type!=ty){ error(r,*n,"gstore type mismatch"); r.success=false; } if(val[0]=='%'){ auto vt=get_var(val.substr(1)); if(vt!=(TypeId)-1 && vt!=ty){ error(r,*n,"gstore value type mismatch"); r.success=false; } } else { error(r,*n,"gstore value must be %var"); r.success=false; } continue; }
    if(op=="index"){ if(il.size()!=5){ error(r,*n,"index arity"); r.success=false; continue; } std::string dst=sym(1), base=sym(3), idx=sym(4); if(dst.empty()||base.empty()||idx.empty()){ error(r,*n,"index symbols"); r.success=false; continue; } TypeId elem=parse_type_node(il[2],r); if(base[0]=='%'){ auto bt=get_var(base.substr(1)); if(bt==(TypeId)-1){ error(r,*n,"base undefined"); r.success=false; } else { const Type& BT=ctx_.at(bt); if(BT.kind!=Type::Kind::Pointer){ error(r,*n,"index base not pointer"); r.success=false; } else { const Type& AT=ctx_.at(BT.pointee); if(AT.kind!=Type::Kind::Array || AT.elem!=elem){ error(r,*n,"index base not pointer to array elem type"); r.success=false; } } } } if(idx[0]=='%'){ auto it=get_var(idx.substr(1)); if(it!=(TypeId)-1 && !is_int(it)){ error(r,*n,"index must be int"); r.success=false; } } if(dst[0]=='%'){ var_types_[dst.substr(1)]=ctx_.get_pointer(elem); attach(n, ctx_.get_pointer(elem)); } else { error(r,*n,"index dst must be %var"); r.success=false; } continue; }
    if(op=="alloca"){ if(il.size()!=3){ error(r,*n,"alloca arity"); r.success=false; continue; } std::string dst=sym(1); if(dst.empty()||dst[0] != '%'){ error(r,*n,"alloca dst must be %var"); r.success=false; continue; } TypeId ty=parse_type_node(il[2],r); TypeId pty=ctx_.get_pointer(ty); var_types_[dst.substr(1)]=pty; attach(n,pty); continue; }
    if(op=="call"){ if(il.size()<4){ error(r,*n,"call arity"); r.success=false; continue; } std::string dst=sym(1); if(dst.empty()||dst[0] != '%'){ error(r,*n,"call dst must be %var"); r.success=false; continue; } TypeId ret=parse_type_node(il[2],r); std::string callee=sym(3); if(callee.empty()){ error(r,*n,"call callee symbol required"); r.success=false; continue; } FunctionInfoTC* finfo=nullptr; if(!lookup_function(callee, finfo)){ error(r,*n,"unknown callee"); r.success=false; } if(finfo && ret!=finfo->ret){ error(r,*n,"call return type mismatch"); r.success=false; } if(finfo){ size_t expected=finfo->params.size(); size_t provided= (il.size()>4)? il.size()-4:0; if(provided!=expected){ error(r,*n,"call arg count mismatch"); r.success=false; } else { for(size_t ai=0; ai<provided; ++ai){ std::string av=sym(4+ai); if(av.empty()||av[0] != '%'){ error(r,*n,"call arg must be %var"); r.success=false; continue; } auto at=get_var(av.substr(1)); if(at==(TypeId)-1){ error(r,*n,"unknown arg var"); r.success=false; continue; } if(at!=finfo->params[ai].type){ error(r,*n,"call arg type mismatch"); r.success=false; } } } } var_types_[dst.substr(1)]=ret; attach(n,ret); continue; }
    error(r,*n,"unknown instruction"); r.success=false; }
}
inline TypeCheckResult TypeChecker::check_module(const node_ptr& m){ TypeCheckResult res{true,{}}; if(!m||!std::holds_alternative<list>(m->data)){ res.success=false; res.errors.push_back(TypeError{"module not list",-1,-1}); return res; } auto &l=std::get<list>(m->data).elems; if(l.empty()||!std::holds_alternative<symbol>(l[0]->data) || std::get<symbol>(l[0]->data).name!="module"){ res.success=false; res.errors.push_back(TypeError{"expected (module ...)",-1,-1}); return res; } reset(); collect_structs(res,l); collect_globals(res,l); collect_functions_headers(res,l); if(res.success) check_functions(res,l); return res; }

} // namespace edn
