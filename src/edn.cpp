// edn.cpp - Clean IR emitter implementation (fully rewritten after corruption)
#include "edn/edn.hpp"
#include "edn/ir_emitter.hpp"

#include <llvm/IR/LLVMContext.h>
#include <llvm/IR/Module.h>
#include <llvm/IR/Type.h>
#include <llvm/IR/DerivedTypes.h>
#include <llvm/IR/IRBuilder.h>
#include <llvm/IR/Verifier.h>
#include <cstdlib>

namespace edn {

static std::string symName(const node_ptr& n){ if(!n) return {}; if(std::holds_alternative<symbol>(n->data)) return std::get<symbol>(n->data).name; if(std::holds_alternative<std::string>(n->data)) return std::get<std::string>(n->data); return {}; }
static std::string trimPct(const std::string& s){ return (!s.empty() && s[0]=='%') ? s.substr(1) : s; }

IREmitter::IREmitter(TypeContext& tctx): tctx_(tctx){ llctx_ = std::make_unique<llvm::LLVMContext>(); }
IREmitter::~IREmitter() = default;

llvm::Type* IREmitter::map_type(TypeId id){ const Type& T=tctx_.at(id); switch(T.kind){
	case Type::Kind::Base: switch(T.base){
		case BaseType::I1: return llvm::Type::getInt1Ty(*llctx_);
		case BaseType::I8: return llvm::Type::getInt8Ty(*llctx_);
		case BaseType::I16: return llvm::Type::getInt16Ty(*llctx_);
		case BaseType::I32: return llvm::Type::getInt32Ty(*llctx_);
		case BaseType::I64: return llvm::Type::getInt64Ty(*llctx_);
		case BaseType::U8: return llvm::Type::getInt8Ty(*llctx_);
		case BaseType::U16: return llvm::Type::getInt16Ty(*llctx_);
		case BaseType::U32: return llvm::Type::getInt32Ty(*llctx_);
		case BaseType::U64: return llvm::Type::getInt64Ty(*llctx_);
		case BaseType::F32: return llvm::Type::getFloatTy(*llctx_);
		case BaseType::F64: return llvm::Type::getDoubleTy(*llctx_);
		case BaseType::Void: return llvm::Type::getVoidTy(*llctx_); }
	case Type::Kind::Pointer: return llvm::PointerType::getUnqual(map_type(T.pointee));
	case Type::Kind::Struct: { if(auto existing=llvm::StructType::getTypeByName(*llctx_,"struct."+T.struct_name)) return existing; return llvm::StructType::create(*llctx_,"struct."+T.struct_name); }
	case Type::Kind::Function: { std::vector<llvm::Type*> ps; ps.reserve(T.params.size()); for(auto p:T.params) ps.push_back(map_type(p)); return llvm::FunctionType::get(map_type(T.ret), ps, T.variadic); }
	case Type::Kind::Array: return llvm::ArrayType::get(map_type(T.elem),(uint64_t)T.array_size);
 }
 return llvm::Type::getVoidTy(*llctx_);
}

llvm::StructType* IREmitter::get_or_create_struct(const std::string& name,const std::vector<TypeId>& field_types){ if(auto it=struct_types_.find(name); it!=struct_types_.end()) return it->second; auto* ST=llvm::StructType::getTypeByName(*llctx_,"struct."+name); if(!ST) ST=llvm::StructType::create(*llctx_,"struct."+name); std::vector<llvm::Type*> elems; elems.reserve(field_types.size()); for(auto ft:field_types) elems.push_back(map_type(ft)); if(ST->isOpaque()) ST->setBody(elems,false); struct_types_[name]=ST; return ST; }

llvm::Module* IREmitter::emit(const node_ptr& module_ast, TypeCheckResult& tc_result){
	TypeChecker checker(tctx_); tc_result = checker.check_module(module_ast); if(!tc_result.success) return nullptr;
	module_ = std::make_unique<llvm::Module>("edn.module", *llctx_);
	if(!module_ast || !std::holds_alternative<list>(module_ast->data)) return nullptr; auto &top = std::get<list>(module_ast->data).elems; if(top.empty()) return nullptr;

	auto collect_structs = [&](const std::vector<node_ptr>& elems){ for(auto &n: elems){ if(!n||!std::holds_alternative<list>(n->data)) continue; auto &l=std::get<list>(n->data).elems; if(l.empty()) continue; if(!std::holds_alternative<symbol>(l[0]->data)|| std::get<symbol>(l[0]->data).name!="struct") continue; std::string sname; std::vector<TypeId> ftypes; std::vector<std::string> fnames; for(size_t i=1;i<l.size();++i){ if(!std::holds_alternative<keyword>(l[i]->data)) continue; std::string kw=std::get<keyword>(l[i]->data).name; if(++i>=l.size()) break; auto val=l[i]; if(kw=="name") sname=symName(val); else if(kw=="fields" && std::holds_alternative<vector_t>(val->data)){ for(auto &f: std::get<vector_t>(val->data).elems){ if(!f||!std::holds_alternative<list>(f->data)) continue; auto &fl=std::get<list>(f->data).elems; std::string fname; TypeId fty=0; for(size_t k=0;k<fl.size(); ++k){ if(!std::holds_alternative<keyword>(fl[k]->data)) continue; std::string fkw=std::get<keyword>(fl[k]->data).name; if(++k>=fl.size()) break; auto v=fl[k]; if(fkw=="name") fname=symName(v); else if(fkw=="type") try{ fty=tctx_.parse_type(v);}catch(...){} } if(!fname.empty()&&fty){ fnames.push_back(fname); ftypes.push_back(fty);} } } } if(!sname.empty()&& !ftypes.empty()){ get_or_create_struct(sname,ftypes); struct_field_types_[sname]=ftypes; auto &m=struct_field_index_[sname]; for(size_t ix=0; ix<fnames.size(); ++ix) m[fnames[ix]]=ix; } } };
	auto emit_globals = [&](const std::vector<node_ptr>& elems){ for(auto &n: elems){ if(!n||!std::holds_alternative<list>(n->data)) continue; auto &l=std::get<list>(n->data).elems; if(l.empty()) continue; if(!std::holds_alternative<symbol>(l[0]->data)||std::get<symbol>(l[0]->data).name!="global") continue; std::string gname; TypeId gty=0; node_ptr init; for(size_t i=1;i<l.size(); ++i){ if(!std::holds_alternative<keyword>(l[i]->data)) continue; std::string kw=std::get<keyword>(l[i]->data).name; if(++i>=l.size()) break; auto v=l[i]; if(kw=="name") gname=symName(v); else if(kw=="type") try{ gty=tctx_.parse_type(v);}catch(...){} else if(kw=="init") init=v; } if(gname.empty()||!gty) continue; llvm::Type* lty=map_type(gty); llvm::Constant* c=nullptr; if(init){ if(std::holds_alternative<int64_t>(init->data)) c=llvm::ConstantInt::get(lty,(uint64_t)std::get<int64_t>(init->data),true); else if(std::holds_alternative<double>(init->data)) c=llvm::ConstantFP::get(lty,std::get<double>(init->data)); } if(!c) c=llvm::Constant::getNullValue(lty); new llvm::GlobalVariable(*module_, lty, false, llvm::GlobalValue::ExternalLinkage, c, gname); } };
	collect_structs(top); emit_globals(top);

	for(size_t i=1;i<top.size(); ++i){ auto fn=top[i]; if(!fn||!std::holds_alternative<list>(fn->data)) continue; auto &fl=std::get<list>(fn->data).elems; if(fl.empty()) continue; if(!std::holds_alternative<symbol>(fl[0]->data)|| std::get<symbol>(fl[0]->data).name!="fn") continue; std::string fname; TypeId retTy=tctx_.get_base(BaseType::Void); std::vector<std::pair<std::string,TypeId>> params; node_ptr body; for(size_t j=1;j<fl.size(); ++j){ if(!std::holds_alternative<keyword>(fl[j]->data)) continue; std::string kw=std::get<keyword>(fl[j]->data).name; if(++j>=fl.size()) break; auto val=fl[j]; if(kw=="name") fname=symName(val); else if(kw=="ret") try{ retTy=tctx_.parse_type(val);}catch(...){} else if(kw=="params" && std::holds_alternative<vector_t>(val->data)){ for(auto &p: std::get<vector_t>(val->data).elems){ if(!p||!std::holds_alternative<list>(p->data)) continue; auto &pl=std::get<list>(p->data).elems; if(pl.size()!=3) continue; if(!std::holds_alternative<symbol>(pl[0]->data)|| std::get<symbol>(pl[0]->data).name!="param") continue; try{ TypeId pty=tctx_.parse_type(pl[1]); std::string pname=trimPct(symName(pl[2])); if(!pname.empty()) params.emplace_back(pname,pty);}catch(...){} } } else if(kw=="body" && std::holds_alternative<vector_t>(val->data)) body=val; }
		if(fname.empty()||!body) continue; std::vector<TypeId> paramIds; for(auto &pr: params) paramIds.push_back(pr.second); auto ftyId=tctx_.get_function(paramIds, retTy); auto *fty=llvm::cast<llvm::FunctionType>(map_type(ftyId)); auto *F=llvm::Function::Create(fty, llvm::Function::ExternalLinkage, fname, module_.get()); size_t ai=0; for(auto &arg: F->args()) arg.setName(params[ai++].first); auto *entry=llvm::BasicBlock::Create(*llctx_,"entry",F); llvm::IRBuilder<> builder(entry); std::unordered_map<std::string,llvm::Value*> vmap; std::unordered_map<std::string,TypeId> vtypes; for(auto &pr: params){ vtypes[pr.first]=pr.second; } for(auto &arg: F->args()){ vmap[std::string(arg.getName())]=&arg; }
		std::vector<llvm::BasicBlock*> loopEndStack; int cfCounter=0; bool functionDone=false;
		auto emit_list = [&](const std::vector<node_ptr>& insts, auto&& emit_ref) -> void {
			if(functionDone) return; for(auto &inst: insts){ if(functionDone) break; if(!inst||!std::holds_alternative<list>(inst->data)) continue; auto &il=std::get<list>(inst->data).elems; if(il.empty()) continue; if(!std::holds_alternative<symbol>(il[0]->data)) continue; std::string op=std::get<symbol>(il[0]->data).name;
				auto getVal=[&](const node_ptr& n)->llvm::Value*{ std::string nm=trimPct(symName(n)); if(nm.empty()) return nullptr; auto it=vmap.find(nm); return (it!=vmap.end())?it->second:nullptr; };
				if(op=="const" && il.size()==4){ std::string dst=trimPct(symName(il[1])); if(dst.empty()) continue; TypeId ty; try{ ty=tctx_.parse_type(il[2]); }catch(...){ continue; } llvm::Type* lty=map_type(ty); llvm::Value* cv=nullptr; if(std::holds_alternative<int64_t>(il[3]->data)) cv=llvm::ConstantInt::get(lty,(uint64_t)std::get<int64_t>(il[3]->data),true); else if(std::holds_alternative<double>(il[3]->data)) cv=llvm::ConstantFP::get(lty,std::get<double>(il[3]->data)); if(!cv) cv=llvm::UndefValue::get(lty); vmap[dst]=cv; vtypes[dst]=ty; }
				else if((op=="add"||op=="sub"||op=="mul"||op=="sdiv"||op=="udiv"||op=="srem"||op=="urem") && il.size()==5){ std::string dst=trimPct(symName(il[1])); TypeId ty; try{ ty=tctx_.parse_type(il[2]); }catch(...){ continue; } auto *va=getVal(il[3]); auto *vb=getVal(il[4]); if(!va||!vb||dst.empty()) continue; llvm::Value* r=nullptr; if(op=="add") r=builder.CreateAdd(va,vb,dst); else if(op=="sub") r=builder.CreateSub(va,vb,dst); else if(op=="mul") r=builder.CreateMul(va,vb,dst); else if(op=="sdiv") r=builder.CreateSDiv(va,vb,dst); else if(op=="udiv") r=builder.CreateUDiv(va,vb,dst); else if(op=="srem") r=builder.CreateSRem(va,vb,dst); else r=builder.CreateURem(va,vb,dst); vmap[dst]=r; vtypes[dst]=ty; }
				else if((op=="fadd"||op=="fsub"||op=="fmul"||op=="fdiv") && il.size()==5){ std::string dst=trimPct(symName(il[1])); TypeId ty; try{ ty=tctx_.parse_type(il[2]); }catch(...){ continue; } auto *va=getVal(il[3]); auto *vb=getVal(il[4]); if(!va||!vb||dst.empty()) continue; llvm::Value* r=nullptr; if(op=="fadd") r=builder.CreateFAdd(va,vb,dst); else if(op=="fsub") r=builder.CreateFSub(va,vb,dst); else if(op=="fmul") r=builder.CreateFMul(va,vb,dst); else r=builder.CreateFDiv(va,vb,dst); vmap[dst]=r; vtypes[dst]=ty; }
				else if(op=="fcmp" && il.size()==7){ std::string dst=trimPct(symName(il[1])); if(dst.empty()) continue; if(!std::holds_alternative<keyword>(il[3]->data)) continue; std::string pred=symName(il[4]); auto *va=getVal(il[5]); auto *vb=getVal(il[6]); if(!va||!vb) continue; llvm::CmpInst::Predicate P=llvm::CmpInst::FCMP_OEQ; if(pred=="oeq") P=llvm::CmpInst::FCMP_OEQ; else if(pred=="one") P=llvm::CmpInst::FCMP_ONE; else if(pred=="olt") P=llvm::CmpInst::FCMP_OLT; else if(pred=="ogt") P=llvm::CmpInst::FCMP_OGT; else if(pred=="ole") P=llvm::CmpInst::FCMP_OLE; else if(pred=="oge") P=llvm::CmpInst::FCMP_OGE; else continue; auto* res=builder.CreateFCmp(P,va,vb,dst); vmap[dst]=res; vtypes[dst]=tctx_.get_base(BaseType::I1); }
				else if((op=="eq"||op=="ne"||op=="lt"||op=="gt"||op=="le"||op=="ge") && il.size()==5){ std::string dst=trimPct(symName(il[1])); if(dst.empty()) continue; auto *va=getVal(il[3]); auto *vb=getVal(il[4]); if(!va||!vb) continue; llvm::CmpInst::Predicate P=llvm::CmpInst::ICMP_EQ; if(op=="eq") P=llvm::CmpInst::ICMP_EQ; else if(op=="ne") P=llvm::CmpInst::ICMP_NE; else if(op=="lt") P=llvm::CmpInst::ICMP_SLT; else if(op=="gt") P=llvm::CmpInst::ICMP_SGT; else if(op=="le") P=llvm::CmpInst::ICMP_SLE; else P=llvm::CmpInst::ICMP_SGE; auto* res=builder.CreateICmp(P,va,vb,dst); vmap[dst]=res; vtypes[dst]=tctx_.get_base(BaseType::I1); }
				else if(op=="icmp" && il.size()==7){ std::string dst=trimPct(symName(il[1])); if(dst.empty()) continue; if(!std::holds_alternative<keyword>(il[3]->data)) continue; std::string pred=symName(il[4]); auto *va=getVal(il[5]); auto *vb=getVal(il[6]); if(!va||!vb) continue; llvm::CmpInst::Predicate P=llvm::CmpInst::ICMP_EQ; if(pred=="eq") P=llvm::CmpInst::ICMP_EQ; else if(pred=="ne") P=llvm::CmpInst::ICMP_NE; else if(pred=="slt") P=llvm::CmpInst::ICMP_SLT; else if(pred=="sgt") P=llvm::CmpInst::ICMP_SGT; else if(pred=="sle") P=llvm::CmpInst::ICMP_SLE; else if(pred=="sge") P=llvm::CmpInst::ICMP_SGE; else if(pred=="ult") P=llvm::CmpInst::ICMP_ULT; else if(pred=="ugt") P=llvm::CmpInst::ICMP_UGT; else if(pred=="ule") P=llvm::CmpInst::ICMP_ULE; else if(pred=="uge") P=llvm::CmpInst::ICMP_UGE; else continue; auto* res=builder.CreateICmp(P,va,vb,dst); vmap[dst]=res; vtypes[dst]=tctx_.get_base(BaseType::I1); }
				else if((op=="and"||op=="or"||op=="xor"||op=="shl"||op=="lshr"||op=="ashr") && il.size()==5){ std::string dst=trimPct(symName(il[1])); TypeId ty; try{ ty=tctx_.parse_type(il[2]); }catch(...){ continue; } auto *va=getVal(il[3]); auto *vb=getVal(il[4]); if(!va||!vb||dst.empty()) continue; llvm::Value* r=nullptr; if(op=="and") r=builder.CreateAnd(va,vb,dst); else if(op=="or") r=builder.CreateOr(va,vb,dst); else if(op=="xor") r=builder.CreateXor(va,vb,dst); else if(op=="shl") r=builder.CreateShl(va,vb,dst); else if(op=="lshr") r=builder.CreateLShr(va,vb,dst); else r=builder.CreateAShr(va,vb,dst); vmap[dst]=r; vtypes[dst]=ty; }
				else if(op=="assign" && il.size()==3){ std::string dst=trimPct(symName(il[1])); std::string src=trimPct(symName(il[2])); if(dst.empty()||src.empty()) continue; auto it=vmap.find(src); if(it!=vmap.end()){ vmap[dst]=it->second; if(vtypes.count(src)) vtypes[dst]=vtypes[src]; } }
				else if(op=="alloca" && il.size()==3){ std::string dst=trimPct(symName(il[1])); if(dst.empty()) continue; TypeId ty; try{ ty=tctx_.parse_type(il[2]); }catch(...){ continue; } auto *av=builder.CreateAlloca(map_type(ty), nullptr, dst); vmap[dst]=av; vtypes[dst]=tctx_.get_pointer(ty); }
				else if(op=="store" && il.size()==4){ std::string ptrn=trimPct(symName(il[2])); std::string valn=trimPct(symName(il[3])); if(ptrn.empty()||valn.empty()) continue; auto pit=vmap.find(ptrn); auto vit=vmap.find(valn); if(pit==vmap.end()||vit==vmap.end()) continue; builder.CreateStore(vit->second,pit->second); }
				else if(op=="gload" && il.size()==4){ std::string dst=trimPct(symName(il[1])); if(dst.empty()) continue; TypeId ty; try{ ty=tctx_.parse_type(il[2]); }catch(...){ continue; } std::string gname=symName(il[3]); if(gname.empty()) continue; auto *gv=module_->getGlobalVariable(gname); if(!gv) continue; auto *lv=builder.CreateLoad(map_type(ty), gv, dst); vmap[dst]=lv; vtypes[dst]=ty; }
				else if(op=="gstore" && il.size()==4){ std::string gname=symName(il[2]); std::string valn=trimPct(symName(il[3])); if(gname.empty()||valn.empty()) continue; auto *gv=module_->getGlobalVariable(gname); if(!gv) continue; auto vit=vmap.find(valn); if(vit==vmap.end()) continue; builder.CreateStore(vit->second, gv); }
				else if(op=="load" && il.size()==4){ std::string dst=trimPct(symName(il[1])); if(dst.empty()) continue; TypeId ty; try{ ty=tctx_.parse_type(il[2]); }catch(...){ continue; } std::string ptrn=trimPct(symName(il[3])); auto it=vmap.find(ptrn); if(it==vmap.end()||!vtypes.count(ptrn)) continue; TypeId pty=vtypes[ptrn]; const Type& PT=tctx_.at(pty); if(PT.kind!=Type::Kind::Pointer||PT.pointee!=ty) continue; auto *lv=builder.CreateLoad(map_type(ty), it->second, dst); vmap[dst]=lv; vtypes[dst]=ty; }
				else if(op=="index" && il.size()==5){ std::string dst=trimPct(symName(il[1])); if(dst.empty()) continue; TypeId elemTy; try{ elemTy=tctx_.parse_type(il[2]); }catch(...){ continue; } auto *baseV=getVal(il[3]); auto *idxV=getVal(il[4]); if(!baseV||!idxV) continue; std::string baseName=trimPct(symName(il[3])); if(!vtypes.count(baseName)) continue; TypeId baseTyId=vtypes[baseName]; const Type* baseTy=&tctx_.at(baseTyId); if(baseTy->kind!=Type::Kind::Pointer) continue; const Type* arrTy=&tctx_.at(baseTy->pointee); if(arrTy->kind!=Type::Kind::Array||arrTy->elem!=elemTy) continue; llvm::Value* zero=llvm::ConstantInt::get(llvm::Type::getInt32Ty(*llctx_),0); auto *gep=builder.CreateInBoundsGEP(map_type(baseTy->pointee), baseV, {zero,idxV}, dst); vmap[dst]=gep; vtypes[dst]=tctx_.get_pointer(elemTy); }
				else if(op=="member" && il.size()==5){ std::string dst=trimPct(symName(il[1])); std::string sname=symName(il[2]); std::string base=trimPct(symName(il[3])); std::string fname=symName(il[4]); if(dst.empty()||sname.empty()||base.empty()||fname.empty()) continue; auto bit=vmap.find(base); if(bit==vmap.end()||!vtypes.count(base)) continue; TypeId bty=vtypes[base]; const Type& BT=tctx_.at(bty); TypeId structId=0; bool baseIsPtr=false; if(BT.kind==Type::Kind::Pointer){ baseIsPtr=true; if(tctx_.at(BT.pointee).kind==Type::Kind::Struct) structId=BT.pointee; } else if(BT.kind==Type::Kind::Struct) structId=bty; if(structId==0||!baseIsPtr) continue; const Type& ST=tctx_.at(structId); if(ST.kind!=Type::Kind::Struct || ST.struct_name!=sname) continue; auto stIt=struct_types_.find(sname); if(stIt==struct_types_.end()) continue; auto idxIt=struct_field_index_.find(sname); if(idxIt==struct_field_index_.end()) continue; auto fIt=idxIt->second.find(fname); if(fIt==idxIt->second.end()) continue; size_t fidx=fIt->second; auto ftIt=struct_field_types_.find(sname); if(ftIt==struct_field_types_.end()||fidx>=ftIt->second.size()) continue; llvm::Value* zero=llvm::ConstantInt::get(llvm::Type::getInt32Ty(*llctx_),0); llvm::Value* fieldIndex=llvm::ConstantInt::get(llvm::Type::getInt32Ty(*llctx_),(uint32_t)fidx); auto *gep=builder.CreateInBoundsGEP(stIt->second, bit->second, {zero,fieldIndex}, dst+".addr"); auto *lv=builder.CreateLoad(map_type(ftIt->second[fidx]), gep, dst); vmap[dst]=lv; vtypes[dst]=ftIt->second[fidx]; }
				else if(op=="member-addr" && il.size()==5){ std::string dst=trimPct(symName(il[1])); std::string sname=symName(il[2]); std::string base=trimPct(symName(il[3])); std::string fname=symName(il[4]); if(dst.empty()||sname.empty()||base.empty()||fname.empty()) continue; auto bit=vmap.find(base); if(bit==vmap.end()||!vtypes.count(base)) continue; TypeId bty=vtypes[base]; const Type& BT=tctx_.at(bty); TypeId structId=0; bool baseIsPtr=false; if(BT.kind==Type::Kind::Pointer){ baseIsPtr=true; if(tctx_.at(BT.pointee).kind==Type::Kind::Struct) structId=BT.pointee; } else if(BT.kind==Type::Kind::Struct) structId=bty; if(structId==0||!baseIsPtr) continue; const Type& ST=tctx_.at(structId); if(ST.kind!=Type::Kind::Struct || ST.struct_name!=sname) continue; auto stIt=struct_types_.find(sname); if(stIt==struct_types_.end()) continue; auto idxIt=struct_field_index_.find(sname); if(idxIt==struct_field_index_.end()) continue; auto fIt=idxIt->second.find(fname); if(fIt==idxIt->second.end()) continue; size_t fidx=fIt->second; auto ftIt=struct_field_types_.find(sname); if(ftIt==struct_field_types_.end()||fidx>=ftIt->second.size()) continue; llvm::Value* zero=llvm::ConstantInt::get(llvm::Type::getInt32Ty(*llctx_),0); llvm::Value* fieldIndex=llvm::ConstantInt::get(llvm::Type::getInt32Ty(*llctx_),(uint32_t)fidx); auto *gep=builder.CreateInBoundsGEP(stIt->second, bit->second, {zero,fieldIndex}, dst); vmap[dst]=gep; vtypes[dst]=tctx_.get_pointer(ftIt->second[fidx]); }
				else if(op=="call" && il.size()>=4){ std::string dst=trimPct(symName(il[1])); TypeId retTy; try{ retTy=tctx_.parse_type(il[2]); }catch(...){ continue; } std::string callee=symName(il[3]); if(callee.empty()) continue; llvm::Function* CF=module_->getFunction(callee); if(!CF){ std::vector<llvm::Type*> argLTys; for(size_t ai=4; ai<il.size(); ++ai){ std::string av=trimPct(symName(il[ai])); if(av.empty()||!vtypes.count(av)){ argLTys.clear(); break;} argLTys.push_back(map_type(vtypes[av])); } auto *ftyDecl=llvm::FunctionType::get(map_type(retTy), argLTys, false); CF=llvm::Function::Create(ftyDecl, llvm::Function::ExternalLinkage, callee, module_.get()); } std::vector<llvm::Value*> args; for(size_t ai=4; ai<il.size(); ++ai){ auto *v=getVal(il[ai]); if(!v){ args.clear(); break;} args.push_back(v);} if(args.size()+4!=il.size()) continue; auto *callInst=builder.CreateCall(CF,args, CF->getReturnType()->isVoidTy()?"":dst); if(!CF->getReturnType()->isVoidTy()){ vmap[dst]=callInst; vtypes[dst]=retTy; } }
				else if(op=="if"){ if(il.size()>=3){ std::string cond=trimPct(symName(il[1])); auto itc=vmap.find(cond); if(itc==vmap.end()) continue; auto *thenBB=llvm::BasicBlock::Create(*llctx_,"if.then."+std::to_string(cfCounter++),F); llvm::BasicBlock* elseBB=nullptr; auto *mergeBB=llvm::BasicBlock::Create(*llctx_,"if.end."+std::to_string(cfCounter++),F); bool hasElse=il.size()>=4 && std::holds_alternative<vector_t>(il[3]->data); if(hasElse) elseBB=llvm::BasicBlock::Create(*llctx_,"if.else."+std::to_string(cfCounter++),F); if(!builder.GetInsertBlock()->getTerminator()) builder.CreateCondBr(itc->second, thenBB, hasElse?elseBB:mergeBB); builder.SetInsertPoint(thenBB); if(std::holds_alternative<vector_t>(il[2]->data)) emit_ref(std::get<vector_t>(il[2]->data).elems, emit_ref); if(!thenBB->getTerminator()) builder.CreateBr(mergeBB); if(hasElse){ builder.SetInsertPoint(elseBB); emit_ref(std::get<vector_t>(il[3]->data).elems, emit_ref); if(!elseBB->getTerminator()) builder.CreateBr(mergeBB);} builder.SetInsertPoint(mergeBB);} }
				else if(op=="while"){ if(il.size()>=3 && std::holds_alternative<vector_t>(il[2]->data)){ std::string cond=trimPct(symName(il[1])); auto itc=vmap.find(cond); if(itc==vmap.end()) continue; auto *condBB=llvm::BasicBlock::Create(*llctx_,"while.cond."+std::to_string(cfCounter++),F); auto *bodyBB=llvm::BasicBlock::Create(*llctx_,"while.body."+std::to_string(cfCounter++),F); auto *endBB=llvm::BasicBlock::Create(*llctx_,"while.end."+std::to_string(cfCounter++),F); if(!builder.GetInsertBlock()->getTerminator()) builder.CreateBr(condBB); builder.SetInsertPoint(condBB); builder.CreateCondBr(itc->second, bodyBB, endBB); builder.SetInsertPoint(bodyBB); loopEndStack.push_back(endBB); emit_ref(std::get<vector_t>(il[2]->data).elems, emit_ref); loopEndStack.pop_back(); if(!bodyBB->getTerminator()) builder.CreateBr(condBB); builder.SetInsertPoint(endBB);} }
				else if(op=="break"){ if(!loopEndStack.empty() && !builder.GetInsertBlock()->getTerminator()) builder.CreateBr(loopEndStack.back()); return; }
				else if(op=="ret" && il.size()==3){ std::string rv=trimPct(symName(il[2])); if(!rv.empty() && vmap.count(rv)) builder.CreateRet(vmap[rv]); else if(fty->getReturnType()->isVoidTy()) builder.CreateRetVoid(); else builder.CreateRet(llvm::Constant::getNullValue(fty->getReturnType())); functionDone=true; return; }
			}
		};
		emit_list(std::get<vector_t>(body->data).elems, emit_list);
		if(!entry->getTerminator()){ if(fty->getReturnType()->isVoidTy()) builder.CreateRetVoid(); else builder.CreateRet(llvm::Constant::getNullValue(fty->getReturnType())); }
	}
	return module_.get();
}

llvm::orc::ThreadSafeModule IREmitter::toThreadSafeModule(){ return llvm::orc::ThreadSafeModule(std::move(module_), std::move(llctx_)); }

} // namespace edn
